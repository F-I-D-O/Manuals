# Introduction
In C++, the workflow and especially the build pipeline is much more complicated than in other languages. Therefore, we start with brief overview of the C++ build pipelines. The following scheme shows the possible build pipelines for C++, starting from Integrated developemnt tools (IDE) and ending with the linker.

![C++ Workflow](Build%20tools%20and%20toolsets.png)

This guide presents mostly the following workflows:

- Clion or Visual Studio IDE
- CMake
- any sequencing tool (these are discribed only briefly as they are configured automaticvally by CMake)
- MSVC and GCC compiler toolchains

Appart from the build pipeline, we also cover the dependency management. For this, we focus on the dependency manager vcpkg.

# Compiler Toolchains
There are various toolchains available on Windows and Linux, but we limit this guide for only some of them, specifically those which are frequently updated and works great with Clion.

## MSYS2 (Windows)

- [download](https://www.msys2.org/)
- follow the installation guide on the homepage
- install MinGW64 using: `pacman -S mingw-w64-x86_64-gcc`


## MSVC (Windows)

-   install [Visual Studio 2019 Comunity Edition](https://visualstudio.microsoft.com/cs/vs/)


### Choosing the runtime library
[official documentation](https://learn.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library)

When compiling with MSVC, it is crucial to choose the correct runtime library. Typically, both the compiled target and all its dependencies have to use the same runtime library. The following options are available:

| Option | Copiler flag | MSBuild name | Description | Linged library |
|--------|--------------|--------------|-------------|----------------|
| Multi-threaded Dynamic | `/MD` | `MultiThreadedDLL` | The default option. The application uses the dynamic version of the runtime library.  | `msvcrt.lib` |
| Multi-threaded Dynamic Debug | `/MDd` |  `MultiThreadedDebugDLL` | The debug version of the dynamic runtime library. | `msvcrtd.lib` |
| Multi-threaded Static | `/MT` | `MultiThreaded` | The application uses the static version of the runtime library. | `libcmt.lib` |
| Multi-threaded Static Debug | `/MTd` | `MultiThreadedDebug` | The debug version of the static runtime library. | `libcmtd.lib` |
| DLL | `/LD` | | The application is compiled as a DLL. | - |
| DLL Debug | `/LDd` | | The debug version of the DLL. | - |

By default, the `/MD`/`/MDd` flags are used depending on the build type. 

When the mismatch occurs, we usually get the following error message:
```plaintext
LNK2038 mismatch detected for 'RuntimeLibrary': value 'MDd_DynamicDebug' doesn't match value 'MTd_StaticDebug' in ..
```
To determine if the type of the runtime library used by the target, we can explore the build script for the target, For MSBuild, the runtime library is set by the `RuntimeLibrary` property.

To determine the runtime library used by a library, we can use the [dumpbin](https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference) tool.
This tool is part of the Visual Studio installation and can be run from the Developer Command Prompt or Developer PowerShell. The following command will display the runtime library used by the library:
```bash
dumpbin /directives <path to the library>
```

#### Resources

- [Standard library description](https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features)

### Common Compiler Flags

- [`/nologo`](https://learn.microsoft.com/en-us/cpp/build/reference/nologo-suppress-startup-banner-c-cpp): do not print the copyright banner and information messages
- [`/EH`](https://learn.microsoft.com/en-us/cpp/build/reference/eh-exception-handling-model): exception handeling flags
    

## GCC (Linux/WSL)

### Installation

1. If on Windows, [Install the WSL](https://docs.microsoft.com/en-us/windows/wsl/install-win10) first (WSL 2)
2. check if GCC is installed by typing `gcc --version`

If GCC is not installed:

1. `sudo apt-get update`
3. `sudo apt-get upgrade`
4. `sudo apt-get install gcc-<version>`

### g++
`g++` is the main executable for the GCC compiler. It is botha compiler and a wrapper for the linker. Typical usage is:

- `g++ -o <output file> <cpp files and library files>`: compilation and linking 
- `g++ -c <cpp files>`: compilation only
- `g++  -o <output file> <object files and library files>`: linking only

Other frequently used flags are:

- `-g`: include debug information
- `-l<library>`: link the library named `lib<library>`. Unlike direct library specification, here the linkers searches for the library in standard directories.


# Build Sequencing Tools

## Make
Most of the time, make scripts should not be written manually, but generated by build script generators like CMake. Therefore, here, we describe the structure of make scripts as they are generated by CMake. The structure is:

- `Makefile`: the main file that contains the rules for building the project
- `CMakeFiles`: a directory containing the files referenced in the `Makefile`
	- `<target name>.dir` directory for each target
		- `link.txt`: the file containing the linking command

## MSBuild
The MSBuild is a XML-based build sequencing tool. The scripts are typically generated by CMake or directly by Visual Studio.

The main file for each target is the `<target name>.vcxproj` file. All properties are stored in the root element `<Project>`. 
The structure inside the project element is as follows (only the most important elements are listed):

- `<ItemDefinitionGroup Condition="<configuration>">`: contains the properties for the given configuration.
- `<ItemGroup><multiple <ClCompile> elements><ItemGroup>`: contains the source files that are compiled
- `<ItemGroup><multiple <ProjectReference> elements><ItemGroup>`: contains references to other targets (dependencies). Theses targets are built before the current target.

The propertis for each configuration are structured as follows:

- `<ClCompile>`: contains the properties for the compilation of the source files (e.g., language standard, runtime library, etc.)
- `<ResourceCompile>`:
	- `<PreprocessorDefinitions>`: the preprocessor definitions used for the target. These are introduced either by the target itself or by the dependencies.
- `<Link>`: contains the properties for the linking of the target (e.g., the libraries to link, the output file, etc.)


# Cmake

-   Windows: Install CMake from [https://cmake.org/download/](https://cmake.org/download/)
	-  if your CMake is too old (e.g. error: “CMake 3.15 or higher is required”), update CMake (same as new install)
-   Linux:
	-   If cmake is installed already, uninstall it!
	-   Do not use the cmake from linux repositories!!
	-   Download CMake `sh` installer from [https://cmake.org/download/](https://cmake.org/download/)
	-   install:
		1. `sudo chmod +x <INSTALLER>`
		2. `sudo <INSTALLER>`
		3. `sudo rm <INSTALLER>`
	-   add cmake executable to path

Other details about CMake can be found in the CMake Manual.

# vcpkg
Vcpkg is a package manager for C++ libraries it serves as a developement package manager rather than a system package manager. 

VCpkg can work in two modes:

- **Classic mode**: vcpkg is installed centrally. This mode is useful for development and testing.
- [**Manifest mode**](https://learn.microsoft.com/en-us/vcpkg/concepts/manifest-mode): vcpkg is installed in the project directory. This mode is useful for deployment. 

To install vcpkg:

1. clone the repo to the desired location (project directory for manifest mode, any directory for classic mode)
1. run the bootstrap script (`bootstrap-vcpkg.bat` on Windows, `bootstrap-vcpkg.sh` on Linux)
1. for classic mode, add the vcpkg directory to `PATH`, so the program can be run from anywhere
	- Beware that to run it with sudo on linux, [it is not that easy](https://docs.google.com/document/d/19CBUHtO0aUpg-kipnTrbQ3ozn_M1PiM0rH4IHoYrXS0/edit?usp=sharing).

To install a package, run `vcpkg install package`.


## CMake Integration
[documentation](https://learn.microsoft.com/en-us/vcpkg/users/buildsystems/cmake-integration)

By default, CMake does not see the vcpkg. To set up the appropriate enviroment variables, paths, etc., we need to run cmake commands with path to cmake toolchain file: `vcpkg/scripts/buildsystems/vcpkg.cmake`. See the IDE and command line section for the detailed instructions how to execute cmake with the path to the vcpkg toolchain file. 

The toolchain file is executed early on, so it is safe to assume that the environment will be correctly set up before the commands in yor cmake script.


## Directory Structure
vcpkg has the following directory structure:

- `buildtrees`: contains the build directories for each installed package. Each build directory contains the build logs.
- `installed`: contains the installed packages. It has subdirectories for each triplet. Each triplet directory is than divided into folloeing subdirectories:
	- `bin`: contains the shared libraries
	- `debug`: contains the debug version of everything in a similar structure as the triplet directory
	- `examples`: contains example binaries
	- `include`: contains the header files
	- `lib`: contains the static libraries
	- `share`: contains the cmake scripts and other files needed for the integration of the package into a cmake project
	- `tools`: contains the executables installed with vcpkg packages
- `ports`: Contains the package information for each package from the official vcpkg list. There is no special way how to update just the port dir, so update the whole vcpkg by `git pull` in case you need to update the list of available packages.
- `scripts`: various scripts
	- `toolchains`: cmake files that configure the toolchains. There is a special file for each platform (windows, linux, etc.)
- `triplets`: contains the triplet files.

### Modules
Vcpkg has it s own `find_package` macro in the toolchain file. It executes the script: `vcpkg/installed/<tripplet>/share/<package name>/vcpkg-cmake-wrapper.cmake`, if exists. Then, it executes the cmake scripts in that directory using the standard `find_package`, like a cmake config package.

## Triplets
[documentation](https://learn.microsoft.com/en-us/vcpkg/concepts/triplets)

Vcpkg supports installing packages built for multiple platforms and compilers in the same vcpkg installation. To do this, vcpkg uses the concept of *triplets*. A triplet is definition of target environment. Usually, the triplet defines three things:

- the target platform (e.g., x64, arm)
- the target operating system (e.g., windows, linux)
- the target compiler (e.g., msvc, gcc)

The triplet definition is stored in the triplet file in the `<vcpkg root>/triplets` directory.

### Changing the default triplet
To change the default triplet, add a new system variable `VCPKG_DEFAULT_TRIPLET`, so your default library version installed with vcpkg will be x64 (like our builds),  set it to:

- `x64-linux` for Linux Compilers
- `x64-windows` for MSVC
- `x64-MinGW` for MinGW


### Using a custom triplet
If you need to test a specific system environment with vcpkg, you can use a custom triplet.

Typically, you can **create** such a triplet by copying an existing one and modifying it. Typically, you just modify the [triplet variables](https://learn.microsoft.com/en-us/vcpkg/users/triplets) in the file.

To **use** the custom triplet add two arguments to the vcpkg command:

- `--triplet <triplet name>`: the name of the custom triplet
- `--overlay-triplets=<path to the directory containing the custom triplet>`: the path to the directory containing the custom triplet file

To **change the compiler**, it is a little bit more complicated, as there is no triplet variable for the compiler. Instead, we need to provide a custom toolchain:

1. copy an existing toolchain file from the `<vcpkg root>/scripts/toolchains`.
1. modify the toolchain file to use the desired compiler, e.g., by setting the `CMAKE_CXX_COMPILER` variable.
1. in the custom triplet file, set the `VCPKG_CHAINLOAD_TOOLCHAIN_FILE` variable to point to the custom toolchain file.

## Update

1.  `git pull`
2.  bootstrap vcpkg again
	1.  Windows: `bootstrap-vcpkg.bat`   
	2.  Linux: `bootstrap-vcpkg.sh`

## Update package

1. [Update vcpkg](#update)
2. `vcpkg update` to get a list of available updates
3. `vcpkg upgrade --no-dry-run` to actually perform the upgrade

All packages are upgraded by default. To upgrade just one package, supply the name of the package (e.g., zlib:x64-windows) as an argument to `upgrade ` command.

### Upgrade packages matching a pattern
For libraries that are divided into many interdependent packages (like boost), it is useful to upgrade all packages that match a pattern at once. Unfortunately, the `upgrade` command does not support the pattern matching. The following command can be used to upgrade all packages that match a pattern in PowerShell:
```PowerShell
vcpkg update | sls -pattern "boost-\w+" | foreach-object { vcpkg upgrade $_.Matches.Value --no-dry-run }
```

## Package Features
Some libraries have optional features, which are not installed by default, but we can install them explicitely. For example `llvm`. After `vcpkg install llvm` and typing `vcpkg search llvm`:

```
llvm                 10.0.0#6         The LLVM Compiler Infrastructure
llvm[clang]                           Build C Language Family Front-end.
llvm[clang-tools-extra]               Build Clang tools.
...
llvm[target-all]                      Build with all backends.
llvm[target-amdgpu]                   Build with AMDGPU backend.
llvm[target-arm]                      Build with ARM backend.
```
Above, we can see that there are a lot of optional targets. To install the the arm target, for example, we can use `vcpkg install llvm[target-arm]`. Sometimes, a new build of the main package is required, in that case, we need to type `vcpkg install llvm[target-arm] --recurse`.


## Package Versions
In classic mode, there is no way how to control the version of a package. For that, we have to use the manifest mode


## Integrate your library to vcpkg
For complete integration of your library to vcpkg, the following steps are needed:

1. Configure and test the [*CMake installation*](CMake%20Manual.md#install)
1. Crate the port and test it locally (*vcpkg installation*)
3. Submit the port to the vcpkg repository (*publishing*) 

Resources:

- [decovar tutorial](https://decovar.dev/blog/2022/10/30/cpp-dependencies-with-vcpkg/)

### Create the Port

- [The official guide for packageing](https://learn.microsoft.com/en-us/vcpkg/get_started/get-started-packaging)
- [Maintainer guide](https://learn.microsoft.com/en-us/vcpkg/contributing/maintainer-guide)
	- missing details from other guides
	- contains the list of deprecated functions

Vcpkg works with ports which are special directories containing all files describing a C++ package. The usuall process is:
The usual port contain these files:

- `portfile.cmake`: the main file containing the calls to cmake functions that install the package
- `vcpkg.json`: metadata file containing the package name, version, dependencies, etc.
- `usage`: a file containing the usage instructions for the package. These instructions are displayed at the end of the installation process.
	- [example](https://github.com/microsoft/vcpkg-docs/blob/main/vcpkg/examples/adding-usage.md)

A simple `portfile.cmake` can look like this:
```cmake

# download the source code
vcpkg_from_github(
	OUT_SOURCE_PATH SOURCE_PATH
	REPO <reo owner>/<repo name>
	REF <tag name>
	SHA512 <hash of the files>
	HEAD_REF <branch name>
)

# configure the source code
vcpkg_cmake_configure(
	SOURCE_PATH <path to source dir>
)

# build the source code and install it
vcpkg_cmake_install()

# fix the cmake generaed files for vcpkg
vcpkg_cmake_config_fixup(PACKAGE_NAME <package name>)

# install the license
vcpkg_install_copyright(FILE_LIST "${SOURCE_PATH}/LICENSE.txt")

# install the usage file
file(INSTALL "${CMAKE_CURRENT_LIST_DIR}/usage" DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}")
```

Explanation:

- [`vcpkg_from_github`](https://learn.microsoft.com/en-us/vcpkg/maintainers/functions/vcpkg_from_github): downloads the source code from the github repository
	- the `<path to source dir>` is the directory where the `CMakeLists.txt` file is located. It is usually the directory where the source code is downloaded, so we can set it to `${SOURCE_PATH}`
	- the `<hash of the files>` can be easily obtained by:
		1.  setting the `<hash of files> to 0
		2.  running the `vcpkg install <port name>`
		3.  copying the hash from the error message
- [`vcpkg_cmake_configure`](https://learn.microsoft.com/en-us/vcpkg/maintainers/functions/vcpkg_cmake_configure): configures the source code using cmake (wraps the `cmake` command)
- [`vcpkg_cmake_install`](https://learn.microsoft.com/en-us/vcpkg/maintainers/functions/vcpkg_cmake_install): builds and installs the source code (wraps the `cmake --build . --target install` command)
	- the majority of code is in the subroutine [`vcpkg_cmake_build`](https://learn.microsoft.com/en-us/vcpkg/maintainers/functions/vcpkg_cmake_build)
	- **if we need some libraries installed with vcpkg at runtime during the build of the package, we need to use the `ADD_BIN_TO_PATH` option in the `vcpkg_cmake_install` function**. This is needed as the automatic dll copy to the output dir (`VCPKG_APPLOCAL_DEPS`) is disabelled by the `vcpkg_cmake_build` function. This option solve the problem by prepending the `PATH` environment variable with the path to the vcpkg installed libraries (`<vcpkg root>/installed/<triplet>/bin` for release and `<vcpkg root>/installed/<triplet>/debug/bin` for debug).
- [`vcpkg_cmake_config_fixup`](https://learn.microsoft.com/en-us/vcpkg/maintainers/functions/vcpkg_cmake_config_fixup): fixes the cmake generated files for vcpkg. This is needed because the cmake generated files are not compatible with vcpkg. The function fixes the `CMakeConfig.cmake` and `CMakeConfigVersion.cmake` files.
	- the `<package name>` is the name of the package, usually the same as the port name
- [`vcpkg_install_copyright`](https://learn.microsoft.com/en-us/vcpkg/maintainers/functions/vcpkg_install_copyright) installs the license files listed in the `FILE_LIST` argument to `share/<port name>/copyright` file. The `copyright` file is obligatory for the package to be accepted to the vcpkg repository.


The `vcpkg.json` file can look like this:
```json
{
	{
    "name": "fconfig",
    "version-string": "0.1.0",
    "description": "C++ implementation of the fconfig configuration system",
    "homepage": "https://github.com/F-I-D-O/Future-Config",
	"license": "MIT",
    "dependencies": [
        {
            "name" : "vcpkg-cmake",
            "host" : true
        },
        "yaml-cpp",
        "spdlog",
        "inja"
    ]
}
}
```
Here:

- the `license` key is obligatory and has to match the license file of the package
- The dependencies with the `host` key set to `true` are the dependencies that are required for the build, but not for the runtime. 

#### Variables and Functions available in the portfile.cmake
The variables and functions available in the `portfile.cmake` are described in the [create command documentation](https://learn.microsoft.com/en-us/vcpkg/commands/create). The most important variables are:

- `CURRENT_PACKAGES_DIR`: the directory where the package is installed: `<vcpkg root>/installed/<triplet>/<port name>`


### Installation
To install the port locally, run:
```bash
vcpkg install <port name>
```

For this command to work, the port has to be located in `<vcpkg root>/ports/<port name>`. If we want to install the port from an alternative location, we can use the `--overlay-ports` option.  For example, if we have the port stored in the `C:/custom_ports/our_new_port` directory, we can install it by:
```bash
vcpkg install our_new_port --overlay-ports=C:/custom_ports
```

If the port installation is failing and the reason is not clear from stdout, check the logs located in `<vcpkg root>/buildtrees/<port name>/`


#### Reinistallation after changes
During testing, we can reach a scenario where a) we successfully installed the port, b) we need to make some changes. In this case, we need to reinstall the port. However, it is not completely straightforward due to [binary caching](https://learn.microsoft.com/en-us/vcpkg/consume/binary-caching-default). The following steps are needed to reinstall the port:

1. uninstall the port: `vcpkg remove <port name>`
2. disable the binary cache by setting the [`VCPKG_BINARY_SOURCES`](https://learn.microsoft.com/en-us/vcpkg/reference/binarycaching) environment variable to `clear`
	- in PowerShell: `$env:VCPKG_BINARY_SOURCES = "clear"`
	- in bash: `export VCPKG_BINARY_SOURCES=clear`
	- if setting the environment variable does not work (WSL), we can specify the `--binarysource=clear` option in the next step
1. install the port again: `vcpkg install <port name>`




#### Executable installation
In general vcpgk does not allow to install executables, as it is a dependency manager rather than a package manager for OS. However, it is possible to install executables that are intedned to be used as tools (to the `installed/<triplet>/tools` directory) used in the build process. To do so, you have to add the [`vcpgk_copy_tools`](https://learn.microsoft.com/en-us/vcpkg/maintainers/functions/vcpkg_copy_tools) call to the `portfile.cmake` file:
```cmake
vcpkg_copy_tools(
	TOOL_NAMES <tool target name>
	AUTO_CLEAN
)
```
The `AUTO_CLEAN` option ensures that the tools are deleted from the `bin` directory. Without it the tools will be kept in the `bin` directory, resulting in warnings and non-complicance with the vcpkg rules.

The `vcpgk_copy_tools` function also automatically copies the runtime dependencies of the tools to the `tools` directory. 


#### Executing installed tools from cmake
The installed tools can be executed from cmake using cmake comands specified in the [CMake manual](CMake%20Manual.md#executing-external-commands). 

To specify the path to the tools directory, use the [`VCPKG_INSTALLED_DIR`](https://learn.microsoft.com/en-us/vcpkg/users/buildsystems/cmake-integration#vcpkg_installed_dir) and [`VCPKG_TARGET_TRIPLET`](https://learn.microsoft.com/en-us/vcpkg/users/buildsystems/cmake-integration#vcpkg_target_triplet) variables:
```cmake
execute_process(
	COMMAND ${VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/tools/${PROJECT_NAME}/<tool name>
)
```

### Publishing
[official guide](https://learn.microsoft.com/en-us/vcpkg/get_started/get-started-adding-to-registry)

Before publishing the port, we should check for the following:

- all dependencies in `CMakelists.txt` are required (`find_package(<package name> REQUIRED)`) **and** listed in the `vcpkg.json` file in the `dependencies` array
- the port follows the [maintainer guide](https://github.com/microsoft/vcpkg-docs/blob/main/vcpkg/contributing/maintainer-guide.md), especially:
	- the port name does not clash with existing packages (check at [repology](https://repology.org/))
	- the port should work for both Windows and Linux and on both platforms, the port should support both static and dynamic linking.
- the [PR checklist](https://learn.microsoft.com/en-us/vcpkg/contributing/pr-review-checklist) is followed

Then, the submission process is as follows (The *emphezised* steps are not needed in case of fixing a failed release, i.e., when the release was rejected by vcpkg):

1. *create a fork of the vcpkg repository*
1. commit and push the changes to the project repository if not done yet
1. create or replace a release in the projects GitHub repository
1. update the verison in the `vcpkg_from_github` call in `portfile.cmake`
1. update the version in the `vcpkg.json` file
1. pull from the vcpgk fork repository
1. copy the port (`portfile.cmake`, `vcpkg.json` and `usage`) to the vcpkg repository
1. remove the local `SOURCE_PATH` overrides and uncomment the `vcpkg_from_github` call
1. in portfile, assign the correct hash to the `vcpkg_from_github` call
1. test the port installation locally without the `--overlay-ports` option
1. format the `vcpkg.json` file using the `vcpkg format-manifest <path to the vcpkg.json file>` command
1. *create a new branch for the package*
1. commit the changes to the package branch in the vcpkg repository
1. update the port version using the `vcpkg x-add-version <port name>` command
1. commit again to the package branch in the vcpkg repository
1. push the branch to the forked vcpkg repository
1. *open the forked repository in the browser and create a new pull request to the main vcpkg repository*


# IDE

## Clion

### Configuration

#### Set default layout
`Window` -> `Layouts` -> `Save changes in current layout`


#### Set up the new Nova engine
The new Nova engine is a new Clion's engine that is faster and have more features. It is the engine that is used in Visual Studio Resharper C++ plugin. To enable it, go to `settings` -> `Advanced Settings` and under `Clion` check the `Use the ReSharper C++ language engine (Clion Nova)`.

Apart from the new features, the Nova engine can prevent some false errors that are caused by the clangd engine used by the old Clion engine.


#### Set up new surround with template
In Clion, there are two types of surround with templates: `surrond with` and `surround with live template`. The first type use simple predefined templates and cannot be modified. However, the second type can be modified and new templates can be added. 


### Toolchain configuration
Go to `settings` -> `Build, Execution, Deployment` -> `toolchain`, add new toolchain and set:

- Name to whatever you want
- The environment should point to your toolchain:
	- MSVC: `C:\Program Files (x86)\Microsoft Visual Studio\2019\Community`
	- MSYS: `C:\MSYS2` 
	- WSL: From the drop-down list, choose the environment you configured for using with CLion in the previous steps
- Credentials (WSL) click to the setting button next to the credentials and fill
	- host: `localhost`
	- port: `2222`
	- user and password according to your WSL system credentials
- Architecture (non WSL): amd64
- CMake: `C:\Program Files\CMake\bin\cmake.exe`, for WSL, leave it as it is
- other fields should be filled automatically

#### Multiple WSL toolchains
When using multiple WSL toolchains, we need to manually set the compilers. To do so, fill also the `C Compiler` and `C++ Compiler` fields in the toolchain settings with the path to the compiler executable.

### Project configuration
Most project settings resides (hereinafter *Project settings*) in `settings` -> `Build, Execution, Deployment` -> `CMake`. For each build configuration, add a new template and set:

-   `Name` to whatever you want   
-   `Build type` to `debug`
-   To `Cmake options`, add:
	-   path to vcpkg toolchain file:
		-   Linux: `-DCMAKE_TOOLCHAIN_FILE=/opt/vcpkg/scripts/buildsystems/vcpkg.cmake`
		-   Windows: `-DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake`
	-   Set the correct vcpkg triplet
		-   MSVC:   `-DVCPKG_TARGET_TRIPLET=x64-windows`
		-   MinGW:  `-DVCPKG_TARGET_TRIPLET=x64-MinGW`
		-   Linux: `-DVCPKG_TARGET_TRIPLET=x64-linux`

#### WSL extra configuration
The CLion does not see the WSL's environment variables (as of 2023-03, see [here](https://intellij-support.jetbrains.com/hc/en-us/community/posts/5633934229906-Programs-cannot-get-environment-variables-from-wsl)). To fix it, go to *Project settings* and set add the necessary environment variables to `Environment` field. 

#### Configuring only some CMake profiles
When we click on the CMake reconiguration button, all profiles are reconfigured. Unfortunately, there is no way how to configure only some profiles. To work around this, we can deactivate the profiles we do not want to configure. To do so:

1. go to `settings` -> `Build, Execution, Deployment` -> `CMake` 
1. select the profile you want to deactivate
1. uncheck the `Enable profile` checkbox located at the top of the profile settings


### Problems

#### Editor reports errors despite the code compiles in all compilers
This can be caused by the clangd engine used by the old Clion engine. To fix it, enable the new Nova engine.




## Visual Studio

### Installation

1. Install Visual Studio
2. Open/Create a CMake project
3. Install ReSharper C++

### Setting Synchronization

1. Sign-in in Visual Studio using a Mictosoft account. [A lot of settings should be synchronized automatically](https://docs.microsoft.com/en-us/visualstudio/ide/synchronized-settings-in-visual-studio?view=vs-2022).
2. Apply the layout: `Window` -> `Apply Window Layout` -> `<Layout Name>`
3. Sync ReSharper settings: you can share the file: `%APPDATA%\JetBrains\Shared\vAny\` (`~\AppData\Roaming\JetBrains\Shared\vAny\`). 
	- This does not work good though as the files are changed on both sides constantly.
	- unfortunately, as of 01/2023, there is no good way how to share resharper settings
4. Install roamed plugins

### Basic Configuration

1. [Add 120 char guideline](https://marketplace.visualstudio.com/items?itemName=PaulHarrington.EditorGuidelines)
	- install the extension 
	- add the guideline in command window: `Edit.AddGuideline 120`
	- if there is an error *extension ... did not load properly*, you need to install the *developer analytic tools* package to the Visual Studio:
		- Visual Studio Installer -> `modify`
		- Go to the `Individual Components` tab
		- search for the extension and select it
		- proceed with the Visual Studio Modification
1. If you need to use the system CMake, configure it now (described below)
1. If you use `*.tpp` file, configure a support for them (described below).


installation
#### Enable template implementation files (`.*tpp`) syntax highlighting:

-   Go to `Tools` -> `Options` -> `Text Editor` -> `File Extension`
-   select Microsoft Visual C++
-   write `tpp` to the field and click add
-   (reopen the file to see changes)

#### To Change the Build Verbosity

1. Go to `Tools` -> `Options` -> `Projects and Solutions` -> `Build and Run`
2. Change the value of the MSBuild project build output verbosity.
    
### Project Setting

#### Configure Visual Studio to use system CMake:

-   Go to `Project` -> `CMake Settings`
-   it should open the `CMakeSettings.json` file
-   Scroll to the bottom and click on `show advanced settings` 
-   Set the CMake executable to point to the `cmake.exe` file of your system CMake 

#### Build Setting and Enviromental Variables
The build configuration is in the file `CMakePresets.json`, located in the root of the project. The  file can be also opened by right clicking on `CMakeLists.txt` ad selecting `Edit CMake presets`.

##### Set the CMake Toolchain File
To set the vcpkg toolchain file add the following value to the base configuration `cacheVariables` dictionary:
```json
"CMAKE_TOOLCHAIN_FILE": {
    "value": "C:/vcpkg/scripts/buildsystems/vcpkg.cmake",
    "type": "FILEPATH"
}
```

##### Set the Compiler
The MSVC toolchain has two compiler executables, default one, and clang. The default compiler configuration looks like this:

```json
"cacheVariables": {
	...
	"CMAKE_C_COMPILER": "cl.exe",
	"CMAKE_CXX_COMPILER": "cl.exe"
	...
},
```

To change the compiler to clang, replace `cl.exe` by `clang-cl.exe` in both rows.

##### Old Method Using CMakeSettings.json
We can open the build setting by right click on `CMakeList.txt` -> `Cmake Settings`

To configure configure vcpkg toolchain file: Under `General`, fill to the `Cmake toolchain file` the following: `C:/vcpkg/scripts/buildsystems/vcpkg.cmake`

To configure the enviromental variable, edit the `CmakeSettings.json` file directly. The global variables can be set in the `environments` array, the per configuration ones in `<config object>/environments` ([exmaple](https://devblogs.microsoft.com/cppblog/set-environment-variables-for-debug-launch-and-tools-with-cmake-and-open-folder/)).

#### Launch Setting 
The launch settings determins the launch configuration, most importantly, the run arguments. To modify the run arguments:
 1. open the `launch.vs.json` file:
	- use the context menu:
			-   Right-click on `CMakeLists.txt` -> `Add Debug Configuration`
			-   select `default`
	- or open the file directly, it is stored in `<PROJECT DIR>/.vs/`
2.   in `launch.vs.json` configure:
		- `type`: `default` for MSVC or `cppgdb` for WSL
		- `projectTarget`: the name of the target (executable)
		- `name`: the display name in Visual Studio
		- `args`: json array with arguments as strings
			- arguments with spaces have to be quoted with escaped quotes
3.  Select the launch configuration in the drop-down menu next to the play button

If the configuration is not visible in the drop-down menu, double-check the `launch.vs.json` file. The file is not validated, so it is easy to make a typo. If there is any problem, insted of an error, the launch configuration is not available. The following problems are common:

- syntax error in the json (should be marked by red squiggly line)
- typo in the target name

##### Other launch.vs.json options

- `cwd`: the working directory

[Microsoft reference for `launch.vs.json`](https://learn.microsoft.com/en-us/cpp/build/launch-vs-schema-reference-cpp?view=msvc-170)

### WSL Configuration
For using GCC 10:

- go to `CmakeSettings.json` -> `CMake variables and cache`
- select `show advanced variables checkbox`
- set `CMAKE_CXX_COMPILER` variable to `/usr/bin/g++-10`


### Other Configuration

- show white spaces: `Edit` -> `Advanced` -> `View White Space`.
- configure indentation: described [here](https://docs.microsoft.com/en-us/visualstudio/ide/reference/options-text-editor-all-languages-tabs?view=vs-2022)


### Determine Visual Studio version
At total, [there are 5 different versionigs related to Visual Studio](https://blog.knatten.org/2022/08/26/microsoft-c-versions-explained/). 

The version which the [compiler support table](https://en.cppreference.com/w/cpp/compiler_support) refers to is the version of the compiler (`cl.exe`).
we can find it be examining the compiler executable stored in `C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\bin\Hostx64\x64`.

### Problems & solutions
#### Cannot regenerate Cmak cache
go to `./vs` and look for file named `CmakeWorkspaceSettings`. It most likelz contains a line with `disable = true`. Just delete the file, or the specific line.
    
# Installing Library Dependencies

## Vcpkg Libraries

1. type `vcpkg list`, if the library you need is not listed, continue to the next steps
1. type `vcpkg search <library simple name>` and inspect the result to determine the exact name of the package you need
	- if the library is not listed, check the presence in [vcpkg repo](https://repology.org/projects/?inrepo=vcpkg)
	- if the library is in repo, but search does not find it, [update vcpkg](#update)
1. type `vcpkg install <exact name>` to install the package
1. at the end of the installation log, there will be a cmake command needed to integrate the library, put it to the appropriate place to your `CMakeList.txt file`

To display the cmake commands for the installed libraries, just run `vcpkg install <exact name>` again.
    
### Boost
With boost, we should install only the necessary components. Then to include boost, we need:

- `find_package(Boost REQUIRED)`
	- with all compiled components listed
- `target_include_directories(<YOUR TARGET NAME> PUBLIC ${Boost_INCLUDE_DIRS}) `

Sometimes, it may be usefull to find out which boost components require linking. The list in the boost documentation, both for [Unix](https://www.boost.org/doc/libs/1_85_0/more/getting_started/unix-variants.html#header-only-libraries) and [Windows](https://www.boost.org/doc/libs/1_85_0/more/getting_started/windows.html#header-only-libraries).

### JNI
for JNI, a `JAVA_HOME` system property needs to be set to the absolute path to the JDK, e.g., `C:\Program Files\Java\jdk-15.0.1`

## Gurobi
 1.  If you don’t have Gurobi installed, do it now, and check that the installation is working
	-   Windows: just install as usual  
	-   Linux:
		1. download the archive to `/opt`
		2. `sudo tar xvfz <gurobi archive>`
		3. add the the [file that introduce environment variables needed for gurobi](https://drive.google.com/file/d/1Vr5VReq2_rOMNm4bsC7HJ9xELeiKeiTR/view?usp=sharing) to `etc/profile.d`
 2.  **Linux only:** it is necessary to build the C++ library for your version of the compiler. Steps:
    	1. `cd <GUROBI DIR>/linux64/src/build/`
    	2. `make`
    	3.  `mv libgurobi_c++.a ../../lib/libgurobi_c++_<some id for you, like version>.a`
    	4.  `cd ../../lib/`
    	5.  `ln -sf ./libgurobi_c++<some id for you, like version>.a libgurobi_c++.a`
 3.   Follow [this guide](https://support.gurobi.com/hc/en-us/articles/360039499751-CMake-C-C-compilation-of-Gurobi-projects), specifically:
		1.   put the attached  [our custom FindGUROBI script](https://drive.google.com/file/d/1h9JovBfjxnnQKLjBPIjSfQQpmEhn3VKC/view?usp=sharing) to: 
			 - Windows: `C:\Program Files\CMake\share\cmake-<your cmake
   version>\Modules/`
			 - Linux: `/opt/<CMAKNAME>/share/cmake-<VERSION>/Modules`
		2.   to your `CMakeLists.txt`, add:
				-   `find_package(GUROBI REQUIRED)`
				-   `target_include_directories(<your executable> PRIVATE ${GUROBI_INCLUDE_DIRS})`
				-   `target_link_libraries(<your executable> PRIVATE ${GUROBI_LIBRARY})`
				-   `target_link_libraries(<your executable> PRIVATE optimized ${GUROBI_CXX_LIBRARY} debug ${GUROBI_CXX_DEBUG_LIBRARY})`
		3.   try to load the cmake projects (i.e., generate the build scripts using cmake).
		4.   if the C++ library is not found (`Gurobi c++ library not found`), check whether the correct C++ library is in the gurobi home, the file `<library name>.lib` has to be in the `lib` directory of the gurobi installation. If the file is not there, it is possible that your gurobi version is too old

### Update Gurobi

-   Updating is done by [installing the new version](https://www.gurobi.com/downloads/gurobi-software/) and generating and using [new licence key](https://www.gurobi.com/downloads/end-user-license-agreement-academic/).
-   after update, you need to delete your build dir in order to prevent using of cached path to old Gurobi install
- Also, you need to update the library name on line 10 of the `FindGUROBI.cmake` script.




## Other Libraries Not Available in vcpkg
### Test Library linking/inclusion
For testing purposes, we can follow this simple pattern:

1. build the library
2. include the library: `target_include_directories(<target name> PUBLIC <path to include dir>)`, where include dir is the directory with the main header file of the library.
3. if the library is not the header only library, we need to:
	3.1  link the library: `target_link_libraries(<target name> PUBLIC <path to lib file>)`, where path to lib file is the path to the dynamic library file used for linking (`.so` on Linux, `.lib` on Windows).
	3.2. add the dynamic library to some path visible for the executable
		- here the library file is `.so` on Linux and `.dll` on Windows
		- there are plenty options for the visible path, the most common being the system `PATH` variable, or the directory with the executable. 


## Dependencies with WSL and CLion
In WSL, when combined with CLion, some find scripts does not work, because they depend on system variables, that are not correctly passed from CLIon SSH connection to CMake. Therefore, it is necessary to add hints with absolute path to these scripts. Some of them can be downloaded [here](https://drive.google.com/drive/folders/1rWVl_T3p0cIf6QBYFtc-sEfuA-TUs2CU?usp=sharing). Package that require these hints:

-   JNI
-   Gurobi
    


# Refactoring

The refactoring of C++ code is a complex process, so the number of supported refactoring operations is limited. In Visual Studio, the only supported refactoring operation is renaming. In IntelliJ tools (CLion, ReSharper C++), there are more tools available, but still, the refactoring is not as powerful nor reliable as in Java or Python.

Other alternative is to implement the refactoring manually, with a help of some compiler tools like [clang Refactoring Engine](https://clang.llvm.org/docs/RefactoringEngine.html) ([example project](https://github.com/realincubus/clang-refactor)). 


## Changing Method Signature

As of 2023-10, there is no reliable way how to change the method signature in C++. The most efficient tool is the method signature refactorin in either CLion or ReSharper C++. However, it does not work in all cases, so it is necessary to check and fix the code manually.


# Standard Library
There are two standard libraries in context of C++:

- [**C++ Standard Library**](https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library): contains the standard C++ features described in the C++ standard.
	- On Linux, it is called `libstdc++` (GNU) or `libc++` (LLVM).
	- On Windows, there are two libraries: `UCRTBASE.dll` and `VCRUNTIME140.dll`
- **C Standard Library**: contains the standard C features described in the C standard.
	- On Linux, it is called [`glibc`](https://en.wikipedia.org/wiki/Glibc). To get the version, run `ldd --version`
	- on Windows, same as the C++ standard library

# Exporting symbols for shared libraries

When creating a shared library, we have to specify which symbols are exported. These are the only symbols that can be directly used from the client code. This is done using special keywords. Because the keywords are different for different compilers, usually, some macros are used instead. Typically, these macros:

- use the correct keyword for the compiler
- support disabling the keyword for building static libraries or executables

The macros are typically defined in a dedicated header file called *export header*. This file is then included in every header file that defines a symbol that should be exported. 

For the whole export machinery to work, we need to:

- create the export header file and include it in every header file that defines an exported symbol
- mark the symbols that should be exported with the export macro
- use CMake to supply the correct compiler flags used in the export header

## Creating the Export Header
We can generate the export header file using the [`GenerateExportHeader`](https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html) module. We can get it by the following code:

```cmake
add_library(<target name> SHARED <files>)
generate_export_header(<target name>)
```

This will generate the export header file in the build directory. However, the export file is different for different compilers. Therefore, it is best to copy the file for each compiler and then merge the macros to create a universal export header file. Alternatively, we can use some proven export header file.

Finally, we can store the export header file in the source directory and include it in every header file that defines an exported symbol.


## Marking the Symbols

Usually, we mark the following symbols for export:

- classes: `class <export macro> MyClass{...}`
- functions: `<export macro> <return type> my_function(...)`

Other symbols does not have to be exported as they are automatically exported by the compiler:

- enums and enum classes
- constants
For shared libraries, we have to export symbols. Becasue of the differences between the compilers, and to support using the same headers for both shared and static libraries it is better to use macros

The macro from the `GenerateExportHeader` is named `<target name>_EXPORT`, we can check the exact name in the export header file.

Only the symbols needed by external code should be exported. The exeption is when the the interface use templates. In this case, all symbols used by the template should be exported.


## CMake Configuration

Now the shared library build should work correctly. However, the static library build will be full of warnings, because the export macro is not intended for static libraries. The same is true for executables. Therefore, we need to set a special property for each target that uses the export header and is not a shared library:
```cmake
target_compile_definitions(<static/executable target name> PUBLIC <static condition macro >)
```
The static condition macro from the `GenerateExportHeader` is named `<target name>_STATIC_DEFINE`. If not clear, we can find the exact macros' names in the export header file.


## Resouces

- [tutorial on decovar](https://decovar.dev/blog/2021/03/08/cmake-cpp-library/)






# Ensuring the same runtime library (MSVC) usage
Using the same runtime library is crucial when using the MSVC compiler. At lover levels, the runtime library is set by compiler flags (see the [MSVC section](#msvc-windows)). These flags are automatically passed to the compiler by the build system based on the build configuration files (e.g., `MSBuild` files). If we generate thes files by the IDE (Visual Studio), we have to set the runtime library in the IDE. If they are generated by CMake, there are three possible situations:

- we use the dynamic runtime library (default): nothing has to be done
- the build is handled by vcpkg (libraries installed with `vcpgk install`): the runtime library is set by the [`VCPKG_CRT_LINKAGE`](https://learn.microsoft.com/en-us/vcpkg/users/triplets#vcpkg_crt_linkage) variable in the triplet file. Nothing has to be done.
- we use the static runtime library: we have to set the `CMAKE_MSVC_RUNTIME_LIBRARY` variable in the `CMakeLists.txt` file. if we use vcpgk, we should set it based on the triplet used:

	```cmake
	if (VCPKG_TARGET_TRIPLET MATCHES "-static")
		set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
	endif()
	```


 # Compilation for a specific CPU
 ## MSVC
 MSVC cannot compile for a specific CPU or CPU series. It can, however, use new instructions sets more efficiently if it compiles the code without the support for CPUs thad does not support these instruction sets.

The command for the compiler is: `/arch:<set name> (see [MSVC documentation](https://learn.microsoft.com/en-us/cpp/build/reference/arch-x64?view=msvc-170) for details).


 ## GCC
 In GCC, the [`march`](https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html) option enables compilation for a specific hardware.
ml) option enables compilation for a specific hardware.

pects that you use vcpkg in a per-project configuration. To make it work, add: `-DCMAKE_TOOLCHAIN_FILE=<vcpkg location>/scripts/buildsystems/vcpkg.cmake`
	- To change build options (`option` in `CMakeLists.txt`), run cmake with `-D <option name>=<option value> <build dir>`. Example: `cmake -D BUILD_TESTING=OFF .`

    
## Building
For building, use:
```bash
cmake --build <build dir>
```
where build dir is the directory containing the build scripts (`CmakeFiles` folder).

To list the build options:
```
cmake -L
```

### Specify the build type (Debug, Release)
To build in release mode, or any other build mode except for the default, we need to specify the parameters for CMake. Unfortunately, these parameters depends on the build system:

- **Single-configuration systems** (Unix, MinGW) 
- **Multi-configuration systems** (Visual Studio)

#### Single-configuration systems
Single configuration systems have the build type hardcoded in the build scripts. Therefore, we need to specify the build type for CMake when we generate the build scripts:
```bash
cmake ../ -DCMAKE_BUILD_TYPE=Release
```
**By default, the build type is `Release`**.

#### Multi-configuration systems
In multi-configuration systems, the `-DCMAKE_BUILD_TYPE` parameter is ignored, because the build configuration is supposed to be determined when building the code (i.e., same build scripts for debug and for release). Therefore, we omit it, and instead specify the `--config` parameter when building the code:
```bash
cmake --build . --config Release
```

### Specify the target
We can use the `--target` parameter for that:
```cmake
cmake --build . --target <TARGET NAME>
```

## Clean the source files
Run:
```
cmake --build . --target clean
```


# Handling Case Insensitivity
Windows builds are, in line with the OS, case insensitive. Moreover, the Visual Studio does some magic with names internally, so the build is case insensitive even on VS WSL builds.

The case insensitivity can bring inconsistencies that later breake Unix builds. Therefore, it is desirable to have the build case sensitive even on Windows. Fortunatelly, we can toggle the case sensitivity at the OS level using this PowerShell command:

```PowerShell
Get-ChildItem <PROJECT ROOT PATH> -Recurse -Directory | ForEach-Object { fsutil.exe file setCaseSensitiveInfo $_.FullName enable }
```

Note that this can break the git commits, so it is necessary to also configure git in your case-sensitive repo:
```
git config core.ignorecase false
```




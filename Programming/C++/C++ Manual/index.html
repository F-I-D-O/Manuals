<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>C++ Manual - Manuals</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">
        <link href="../../../extra.css" rel="stylesheet">

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">Manuals</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Programming <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">C++</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../C%20Manual/" class="dropdown-item">C Manual</a>
</li>
            
<li>
    <a href="../C%2B%2B%20Debugging%20and%20Profiling/" class="dropdown-item">C++ Debugging and Profiling</a>
</li>
            
<li>
    <a href="./" class="dropdown-item active">C++ Manual</a>
</li>
            
<li>
    <a href="../C%2B%2B%20Workflow/" class="dropdown-item">C++ Workflow</a>
</li>
            
<li>
    <a href="../CMake%20Manual/" class="dropdown-item">CMake Manual</a>
</li>
            
<li>
    <a href="../Google%20Test/" class="dropdown-item">Google Test</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Cloud computing</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Cloud%20computing/Lmod/" class="dropdown-item">Lmod</a>
</li>
            
<li>
    <a href="../../Cloud%20computing/RCI%20cluster/" class="dropdown-item">RCI cluster</a>
</li>
            
<li>
    <a href="../../Cloud%20computing/Slurm/" class="dropdown-item">Slurm</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Database</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Database/Database%20Workflow/" class="dropdown-item">Database Workflow</a>
</li>
            
<li>
    <a href="../../Database/PostgreSQL%20Debugging%20and%20Profiling/" class="dropdown-item">PostgreSQL Debugging and Profiling</a>
</li>
            
<li>
    <a href="../../Database/PostgreSQL%20Manual/" class="dropdown-item">PostgreSQL Manual</a>
</li>
            
<li>
    <a href="../../Database/SQL%20Manual/" class="dropdown-item">SQL Manual</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Java</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Java/Debugging%20Java/" class="dropdown-item">Debugging Java</a>
</li>
            
<li>
    <a href="../../Java/Jackson/" class="dropdown-item">Jackson</a>
</li>
            
<li>
    <a href="../../Java/Java%20Manual/" class="dropdown-item">Java Manual</a>
</li>
            
<li>
    <a href="../../Java/Java%20Workflow/" class="dropdown-item">Java Workflow</a>
</li>
            
<li>
    <a href="../../Java/Maven/" class="dropdown-item">Maven</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Python</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Python/Matplotlib%20Manual/" class="dropdown-item">Matplotlib Manual</a>
</li>
            
<li>
    <a href="../../Python/Pandas%20Manual/" class="dropdown-item">Pandas Manual</a>
</li>
            
<li>
    <a href="../../Python/Plotly%20Manual/" class="dropdown-item">Plotly Manual</a>
</li>
            
<li>
    <a href="../../Python/Python%20Debugging/" class="dropdown-item">Python Debugging</a>
</li>
            
<li>
    <a href="../../Python/Python%20Manual/" class="dropdown-item">Python Manual</a>
</li>
            
<li>
    <a href="../../Python/Python%20Workflow/" class="dropdown-item">Python Workflow</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Web</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Web/CSS%20Manual/" class="dropdown-item">CSS Manual</a>
</li>
            
<li>
    <a href="../../Web/css/" class="dropdown-item">css</a>
</li>
            
<li>
    <a href="../../Web/Google%20API%20and%20Apps%20Script/" class="dropdown-item">Google API and Apps Script</a>
</li>
            
<li>
    <a href="../../Web/htaccess/" class="dropdown-item">htaccess</a>
</li>
            
<li>
    <a href="../../Web/JavaScript/" class="dropdown-item">JavaScript</a>
</li>
            
<li>
    <a href="../../Web/Jekyll/" class="dropdown-item">Jekyll</a>
</li>
            
<li>
    <a href="../../Web/mkdocs/" class="dropdown-item">mkdocs</a>
</li>
            
<li>
    <a href="../../Web/Selenium/" class="dropdown-item">Selenium</a>
</li>
    </ul>
  </li>
                                    
<li>
    <a href="../../Common/" class="dropdown-item">Common</a>
</li>
                                    
<li>
    <a href="../../Git/" class="dropdown-item">Git</a>
</li>
                                    
<li>
    <a href="../../Gurobi/" class="dropdown-item">Gurobi</a>
</li>
                                    
<li>
    <a href="../../HDF/" class="dropdown-item">HDF</a>
</li>
                                    
<li>
    <a href="../../JSON/" class="dropdown-item">JSON</a>
</li>
                                    
<li>
    <a href="../../Native%20Libraries/" class="dropdown-item">Native Libraries</a>
</li>
                                    
<li>
    <a href="../../Neural%20Networks/" class="dropdown-item">Neural Networks</a>
</li>
                                    
<li>
    <a href="../../Perl/" class="dropdown-item">Perl</a>
</li>
                                    
<li>
    <a href="../../Regex/" class="dropdown-item">Regex</a>
</li>
                                    
<li>
    <a href="../../Ruby%20Workflow/" class="dropdown-item">Ruby Workflow</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">LaTeX <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../LaTeX/Latex%20manual/" class="dropdown-item">Latex manual</a>
</li>
                                    
<li>
    <a href="../../../LaTeX/LaTeX%20workflow/" class="dropdown-item">LaTeX workflow</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Linux <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../Linux/Linux%20Manual/" class="dropdown-item">Linux Manual</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Windows <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../Windows/Excel%20Manual/" class="dropdown-item">Excel Manual</a>
</li>
                                    
<li>
    <a href="../../../Windows/PowerPoint/" class="dropdown-item">PowerPoint</a>
</li>
                                    
<li>
    <a href="../../../Windows/Powershell%20Manual/" class="dropdown-item">Powershell Manual</a>
</li>
                                    
<li>
    <a href="../../../Windows/VSCode/" class="dropdown-item">VSCode</a>
</li>
                                    
<li>
    <a href="../../../Windows/Windows%20Manual/" class="dropdown-item">Windows Manual</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Audio & Video <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../Audio%20%26%20Video/FFMpeg/" class="dropdown-item">FFMpeg</a>
</li>
                                    
<li>
    <a href="../../../Audio%20%26%20Video/VLC/" class="dropdown-item">VLC</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">GIS <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../GIS/GIS%20formats/" class="dropdown-item">GIS formats</a>
</li>
                                    
<li>
    <a href="../../../GIS/Overpass%20Manual/" class="dropdown-item">Overpass Manual</a>
</li>
                                    
<li>
    <a href="../../../GIS/QGIS/" class="dropdown-item">QGIS</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Images <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../../Images/Midjourney/" class="dropdown-item">Midjourney</a>
</li>
                                    
<li>
    <a href="../../../Images/Photopea/" class="dropdown-item">Photopea</a>
</li>
                                </ul>
                            </li>
                            <li class="navitem">
                                <a href="../../../Arxiv/" class="nav-link">Arxiv</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../Google%20office%20apps/" class="nav-link">Google office apps</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../Hardware%20Manual/" class="nav-link">Hardware Manual</a>
                            </li>
                            <li class="navitem">
                                <a href="../../.." class="nav-link">index</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../Markdown/" class="nav-link">Markdown</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../Network/" class="nav-link">Network</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../Security/" class="nav-link">Security</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../vscode/" class="nav-link">vscode</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../Web%20Tricks/" class="nav-link">Web Tricks</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../XML/" class="nav-link">XML</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../YAML/" class="nav-link">YAML</a>
                            </li>
                            <li class="navitem">
                                <a href="../../../Zotero/" class="nav-link">Zotero</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../C%2B%2B%20Debugging%20and%20Profiling/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../C%2B%2B%20Workflow/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#source-and-header-files" class="nav-link">Source and Header Files</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#type-system" class="nav-link">Type System</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#complete-and-incomplete-types" class="nav-link">Complete and Incomplete Types</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#aggregate-types" class="nav-link">Aggregate types</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#type-conversion" class="nav-link">Type Conversion</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#numeric-conversion" class="nav-link">Numeric Conversion</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#implicit-numeric-conversion" class="nav-link">Implicit Numeric Conversion</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="5"><a href="#integral-promotion" class="nav-link">Integral Promotion</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="5"><a href="#integral-conversion" class="nav-link">Integral Conversion</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#usual-arithmetic-conversion" class="nav-link">Usual Arithmetic Conversion</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#show-the-type-at-runtime" class="nav-link">Show the Type at Runtime</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#resolved-complicated-types" class="nav-link">Resolved complicated types</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#show-the-user-provided-types-stdtype_info" class="nav-link">Show the user-provided types (std::type_info)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#built-in-and-stl-types" class="nav-link">Built-in and STL Types</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#arithmetic-types" class="nav-link">Arithmetic Types</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#integers" class="nav-link">Integers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#overflow-and-underflow" class="nav-link">Overflow and Underflow</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#dangerous-situations" class="nav-link">Dangerous situations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#detecting-overflows" class="nav-link">Detecting overflows</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#characters" class="nav-link">Characters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#pointers" class="nav-link">Pointers</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#pointers-to-functions" class="nav-link">Pointers to Functions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#pointers-to-member-objects" class="nav-link">Pointers to Member Objects</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#pointers-to-member-functions" class="nav-link">Pointers to Member Functions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#references" class="nav-link">References</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#rvalue-references" class="nav-link">Rvalue references</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#forwarding-references" class="nav-link">Forwarding references</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#function-parameter-forwarding-references" class="nav-link">Function parameter forwarding references</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#auto-forwarding-reference" class="nav-link">auto forwarding reference</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#arrays" class="nav-link">Arrays</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#static-arrays" class="nav-link">Static arrays</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#dynamic-arrays" class="nav-link">Dynamic arrays</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#array-to-pointer-implicit-conversion" class="nav-link">Array to pointer implicit conversion</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#mutli-dimensional-dynamic-arrays" class="nav-link">Mutli-dimensional dynamic arrays</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#flat-array" class="nav-link">Flat array</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#array-of-pointers-to-array" class="nav-link">Array of pointers to array</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#auto-dealocation-of-dynamic-arrays" class="nav-link">Auto dealocation of dynamic arrays</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#references-and-pointers-to-arrays" class="nav-link">References and Pointers to arrays</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#function-type" class="nav-link">Function Type</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#reference-to-function-and-pointer-to-function-types" class="nav-link">Reference to Function and Pointer to Function Types</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#enumerations" class="nav-link">Enumerations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#smart-pointers" class="nav-link">Smart Pointers</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#creation" class="nav-link">Creation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#shared-pointer" class="nav-link">Shared Pointer</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#stdreference_wrapper" class="nav-link">std::reference_wrapper</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#strings" class="nav-link">Strings</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#string-literals" class="nav-link">String Literals</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#formatting-strings" class="nav-link">Formatting strings</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#spliting-the-string-into-tokens" class="nav-link">Spliting the string into tokens</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#converting-string-to-int" class="nav-link">Converting string to int</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#substring" class="nav-link">Substring</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#change-the-case" class="nav-link">change the case</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#building-strings" class="nav-link">Building strings</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#testting-for-whitespace" class="nav-link">Testting for whitespace</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#date-and-time" class="nav-link">Date and time</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#collections" class="nav-link">Collections</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#sets" class="nav-link">Sets</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#providing-custom-hash-function" class="nav-link">Providing custom hash function</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#implementing-custom-hash-function" class="nav-link">Implementing custom hash function</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#maps" class="nav-link">Maps</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#geeting-value-by-key" class="nav-link">Geeting value by key</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#inserting-into-map" class="nav-link">Inserting into map</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#tuples" class="nav-link">Tuples</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#creating-tuples" class="nav-link">Creating tuples</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="5"><a href="#creating-tuples-with-stdmake_pair-or-stdmake_tuple" class="nav-link">Creating tuples with std::make_pair or std::make_tuple</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#accessing-tuple-members" class="nav-link">Accessing tuple members</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#unpacking-tuples-into-variables" class="nav-link">Unpacking tuples into variables</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="5"><a href="#structured-binding" class="nav-link">Structured binding</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="5"><a href="#stdtie" class="nav-link">std::tie</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#unpacking-tuples-to-constructor-params-with-stdmake_from_tuple" class="nav-link">Unpacking tuples to constructor params with std::make_from_tuple</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#stdoptional" class="nav-link">std::optional</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#unions-and-variants" class="nav-link">Unions and Variants</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#stdvariant" class="nav-link">std::variant</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#storing-individual-bits-in-a-sequence" class="nav-link">Storing individual bits in a sequence</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#reading-a-subsequnece-of-bits" class="nav-link">Reading a subsequnece of bits</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#stdbitset" class="nav-link">std::bitset</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#reading" class="nav-link">Reading</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#value-categories" class="nav-link">Value Categories</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#operators" class="nav-link">Operators</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#user-defined-operators" class="nav-link">User-defined Operators</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#comparison-operators" class="nav-link">Comparison Operators</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#default-comparison-operators" class="nav-link">Default Comparison Operators</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#control-structures" class="nav-link">Control Structures</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#switch-statement" class="nav-link">Switch Statement</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#functions" class="nav-link">Functions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#function-declaration-and-definition" class="nav-link">Function Declaration and Definition</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#merged-declaration-and-definition" class="nav-link">Merged Declaration and Definition</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#deciding-between-free-function-member-function-and-static-member-function" class="nav-link">Deciding between free function, member function and static member function</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#argument-parameter-conversions" class="nav-link">Argument-parameter Conversions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#default-parameters" class="nav-link">Default Parameters</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#default-parameters-and-inheritance" class="nav-link">Default Parameters and Inheritance</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#return-values-and-nrvo" class="nav-link">Return values and NRVO</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#function-overlaoding" class="nav-link">Function Overlaoding</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#conversion-prioritiy-and-ranking" class="nav-link">Conversion prioritiy and ranking</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#conversion-sequence-ranks" class="nav-link">Conversion sequence ranks</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#constructor-argument-type-resolution-in-list-initialization" class="nav-link">Constructor argument type resolution in list initialization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#auto-return-type" class="nav-link">auto return type</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#function-visibility" class="nav-link">Function visibility</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#deleting-functions" class="nav-link">Deleting functions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#classes-and-structs" class="nav-link">Classes and structs</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#class-constants" class="nav-link">Class Constants</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#friend-declaration" class="nav-link">Friend declaration</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#template-friends" class="nav-link">Template friends</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#initialization-and-assignment" class="nav-link">Initialization and Assignment</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#loacal-variables-initializationassignment" class="nav-link">Loacal variables initialization/assignment</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#list-initialization" class="nav-link">List initialization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#value-initialization" class="nav-link">Value initialization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#aggregate-initialization" class="nav-link">Aggregate initialization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#nested-initialization" class="nav-link">Nested initialization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#member-initializationassignment" class="nav-link">Member Initialization/Assignment</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#default-member-initialization" class="nav-link">Default Member Initialization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#member-initializer-list" class="nav-link">Member Initializer List</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#constructor-body" class="nav-link">Constructor Body</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#comparison-table" class="nav-link">Comparison Table</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#constructors-and-special-member-functions" class="nav-link">Constructors and Special Member Functions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#constructor" class="nav-link">Constructor</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#defualt-variant" class="nav-link">Defualt Variant</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#explicit-constructor" class="nav-link">Explicit constructor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#call-one-constructor-from-another" class="nav-link">Call one constructor from another</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#copy-constructor" class="nav-link">Copy Constructor</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#implicit-declaration-and-implicit-deletion" class="nav-link">Implicit declaration and implicit deletion</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#checking-if-a-class-is-copy-constructible" class="nav-link">Checking if a class is copy constructible</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#copy-assignment" class="nav-link">Copy Assignment</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#move-constructor" class="nav-link">Move Constructor</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#implicit-declaration-and-implicit-deletion_1" class="nav-link">Implicit declaration and implicit deletion</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#checking-if-a-class-is-move-constructible" class="nav-link">Checking if a class is move constructible</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#move-assignment" class="nav-link">Move Assignment</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#trivial-special-member-functions" class="nav-link">Trivial special member functions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#destructor" class="nav-link">Destructor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#typical-usage" class="nav-link">Typical usage</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#simple-temporary-object" class="nav-link">Simple Temporary Object</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#unique-object" class="nav-link">Unique Object</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#default-object" class="nav-link">Default Object</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#const-vs-non-const" class="nav-link">Const vs non-const</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#avoiding-duplication-between-const-and-non-const-version-of-the-same-function" class="nav-link">Avoiding duplication between const and non-const version of the same function</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#constnon-const-overloads-and-inheritance" class="nav-link">Const/non const overloads and inheritance</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#io-and-filesystem" class="nav-link">IO and Filesystem</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#file-path-manipulation" class="nav-link">File path manipulation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#filesystem-manipulation" class="nav-link">Filesystem manipulation</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#copying" class="nav-link">Copying</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#creating-directories" class="nav-link">Creating directories</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#removing-files-and-directories" class="nav-link">Removing files and directories</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#other-useful-functions" class="nav-link">Other useful functions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#manual-text-io" class="nav-link">Manual text IO</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#input" class="nav-link">Input</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#output" class="nav-link">Output</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#load-whole-file-into-string" class="nav-link">Load whole file into string</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#csv" class="nav-link">csv</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#input_1" class="nav-link">Input</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#output_1" class="nav-link">Output</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#yaml" class="nav-link">YAML</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hdf" class="nav-link">HDF</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#inheritance" class="nav-link">Inheritance</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#polymorphism" class="nav-link">Polymorphism</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#shadowinghiding-why-is-a-function-from-parent-not-available-in-child" class="nav-link">Shadowing/Hiding: why is a function from parent not available in child?</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#how-to-call-a-hidden-function" class="nav-link">How to call a hidden function?</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#constructors" class="nav-link">Constructors</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#enablinging-parent-constructors-in-child" class="nav-link">Enablinging Parent Constructors in Child</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#inheritance-and-constructorsdestructors" class="nav-link">Inheritance and Constructors/Destructors</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#initializing-base-class-members" class="nav-link">Initializing base class members</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#slicing" class="nav-link">Slicing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#checking-the-type" class="nav-link">Checking the Type</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#covariant-return-type" class="nav-link">Covariant Return Type</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#use-method-from-parent-to-override-a-method-from-other-parent" class="nav-link">Use Method from Parent to Override a Method from Other Parent</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#multiple-inheritance-and-virtual-base-classes" class="nav-link">Multiple inheritance and virtual base classes</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#virtual-inheritance" class="nav-link">Virtual Inheritance</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#multiple-copymove-calls-with-virtual-inheritance" class="nav-link">Multiple copy/move calls with virtual inheritance</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#other-sources" class="nav-link">Other sources</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#templates" class="nav-link">Templates</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#syntax" class="nav-link">Syntax</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#template-declaration" class="nav-link">Template Declaration</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#template-definition" class="nav-link">Template definition</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#organization-rules" class="nav-link">Organization rules</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#providing-template-arguments" class="nav-link">Providing Template Arguments</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#rules-for-omitting-the" class="nav-link">Rules for omitting the &lt;&gt;</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#default-template-arguments" class="nav-link">Default Template Arguments</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#template-argument-deduction" class="nav-link">Template Argument Deduction</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#class-template-argument-deduction-ctad" class="nav-link">Class Template Argument Deduction (CTAD)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#deduction-guides" class="nav-link">Deduction Guides</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#user-defined-deduction-guides" class="nav-link">User defined deduction guides</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#implicit-deduction-guides" class="nav-link">Implicit deduction guides</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="4"><a href="#deduction-guides-resolution" class="nav-link">Deduction guides resolution</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#template-specialization" class="nav-link">Template Specialization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#templates-and-namespaces" class="nav-link">Templates and Namespaces</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#using-complicated-types-as-template-arguments" class="nav-link">Using Complicated Types as Template Arguments</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#type-traits" class="nav-link">Type Traits</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#usefull-type-traits" class="nav-link">Usefull Type Traits</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#replacement-for-old-type-traits" class="nav-link">Replacement for old type traits</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#concepts" class="nav-link">Concepts</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#constraints" class="nav-link">Constraints</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#requires-expression" class="nav-link">Requires Expression</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#auto-filling-the-first-template-argument" class="nav-link">Auto filling the first template argument</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#stl-concepts" class="nav-link">STL Concepts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#usefull-patterns" class="nav-link">Usefull Patterns</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#constrain-a-template-argument" class="nav-link">Constrain a Template Argument</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#constraint-a-concept-argument" class="nav-link">Constraint a Concept Argument</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#sources" class="nav-link">Sources</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#interfaces" class="nav-link">Interfaces</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#interface-using-polymorfism" class="nav-link">Interface using polymorfism</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#using-template-argument-restriction-as-an-interface" class="nav-link">Using template argument restriction as an interface</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#restricting-the-member-function-to-be-const" class="nav-link">Restricting the member function to be const</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#using-concepts-and-polymorphism-together-to-restrict-template-parameters-with-abstract-class" class="nav-link">Using concepts and polymorphism together to restrict template parameters with abstract class</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#the-conflict-between-templates-and-polymorphism" class="nav-link">The Conflict Between Templates and Polymorphism</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#no-virtual-member-function-with-template-parameters" class="nav-link">No Virtual Member Function with Template Parameters</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#polymorphism-cannot-be-used-inside-template-params" class="nav-link">Polymorphism cannot be used inside template params</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#possible-solutions-for-conflicts" class="nav-link">Possible solutions for conflicts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#polymorphic-members-and-containers" class="nav-link">Polymorphic members and containers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#deciding-between-template-and-polymorphism" class="nav-link">Deciding between template and polymorphism</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#iterators-stl-algorithms-and-ranges" class="nav-link">Iterators, STL algorithms, and ranges</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#terminology" class="nav-link">Terminology</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#how-to-choose-the-correct-interface" class="nav-link">How to choose the correct interface?</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#stl-ranges-and-views" class="nav-link">STL ranges and views</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#stl-range-views" class="nav-link">STL range views</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#usefull-views" class="nav-link">Usefull views</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#projections" class="nav-link">Projections</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#useful-range-algorithms" class="nav-link">Useful range algorithms</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#other-resources" class="nav-link">Other Resources</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#boost-ranges" class="nav-link">Boost ranges</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#boost-range-requirements" class="nav-link">Boost range requirements</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#sequences" class="nav-link">Sequences</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#zip" class="nav-link">Zip</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#boostcombine" class="nav-link">boost::combine</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#enumerating" class="nav-link">Enumerating</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#sorting" class="nav-link">Sorting</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#sorting-using-projection" class="nav-link">Sorting using projection</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#transformation" class="nav-link">Transformation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#aggregating-sum-product-etc" class="nav-link">Aggregating (sum, product, etc.)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#implementing-a-custom-range" class="nav-link">Implementing a custom range</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#implementing-an-input-range" class="nav-link">Implementing an input range</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#boost-iterator-templates" class="nav-link">Boost Iterator Templates</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#resources" class="nav-link">Resources</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#lambda-functions" class="nav-link">Lambda Functions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#captures" class="nav-link">Captures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#return-type" class="nav-link">Return type</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#specifiers" class="nav-link">Specifiers</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#exceptions" class="nav-link">Exceptions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#rethrowing-exceptions" class="nav-link">Rethrowing Exceptions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#how-to-catch-any-exception" class="nav-link">How to Catch Any Exception</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#noexcept-specification" class="nav-link">noexcept specification</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#stack-traces" class="nav-link">Stack traces</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#logging" class="nav-link">Logging</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#levels" class="nav-link">Levels</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#colors" class="nav-link">Colors</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#type-aliases" class="nav-link">Type Aliases</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#template-aliasis" class="nav-link">Template Aliasis</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#aliases-inside-classes" class="nav-link">Aliases inside classes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#constant-expressions" class="nav-link">Constant Expressions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#compile-time-branching" class="nav-link">Compile Time Branching</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#regular-expressions" class="nav-link">Regular expressions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#matching-the-result" class="nav-link">Matching the result</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#namespaces" class="nav-link">Namespaces</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#anonymous-namespaces" class="nav-link">Anonymous namespaces</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#namespace-aliases" class="nav-link">Namespace aliases</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#decltype-determining-type-from-expressions" class="nav-link">decltype: Determining Type from Expressions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#the-value-category-of-decltype" class="nav-link">The Value Category of decltype</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#determining-the-return-value-type-of-a-function" class="nav-link">Determining the Return Value Type of a Function</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#-we-cannot-use-abstract-classes-as-arguments-of-stdinvoke_result_t-while-we-can-use-them-inside-decltype-using-stddeclval-see-below" class="nav-link">- we cannot use abstract classes as arguments of std::invoke_result_t, while we can use them inside decltype (using std::declval, see below).</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#construct-object-inside-decltype-with-stddeclval" class="nav-link">Construct object inside decltype with std::declval</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#decltype-and-overloading" class="nav-link">decltype and Overloading</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#parallelization" class="nav-link">Parallelization</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#standard-threads" class="nav-link">Standard Threads</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#for-each-with-parallel-execution-policy" class="nav-link">For-each with Parallel Execution Policy</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#async-tasks" class="nav-link">Async tasks</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#open-mp" class="nav-link">Open-MP</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#standard-templates-for-callables" class="nav-link">Standard Templates for Callables</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#using-stdinvoke-to-call-the-member-function" class="nav-link">Using std::invoke to call the member function</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#using-stdmem_fn-to-store-a-pointer-to-member-function-in-a-callable" class="nav-link">Using std::mem_fn to Store a Pointer to Member Function in a Callable</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#using-a-pointer-to-member-function-as-a-functor" class="nav-link">Using a Pointer to Member Function as a Functor</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#using-lambdas-instead-of-stdbind" class="nav-link">Using Lambdas Instead of std::bind</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#store-the-result-of-stdbind" class="nav-link">Store the Result of std::bind</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#stdmem_fn-and-data-members" class="nav-link">std::mem_fn and Data Members</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#stdfunction" class="nav-link">std::function</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#stdfunction-and-overloading" class="nav-link">std::function and overloading</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#preprocessor-directives" class="nav-link">Preprocessor Directives</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#include" class="nav-link">Include</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#conditional-include" class="nav-link">Conditional include</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#control-structures_1" class="nav-link">Control structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#predefined-macros-for-detecting-compiler-os-etc" class="nav-link">Predefined macros for detecting compiler, OS, etc.</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#debugging-preprocessor-directives" class="nav-link">Debugging preprocessor directives</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#resources_1" class="nav-link">Resources</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#testing-with-google-test" class="nav-link">Testing with Google Test</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#private-method-testing" class="nav-link">Private method testing</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#memory-alignment" class="nav-link">Memory Alignment</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#padding" class="nav-link">Padding</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#structure-alignment-or-final-padding" class="nav-link">Structure Alignment (or final padding)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-level="1"><a href="#specific-tasks" class="nav-link">specific tasks</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#conditional-function-execution" class="nav-link">Conditional Function Execution</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#function-parameter" class="nav-link">Function Parameter</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#template-parameter" class="nav-link">Template Parameter</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="3"><a href="#compiler-directive" class="nav-link">Compiler Directive</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ignoring-warnings-for-specific-line-of-code" class="nav-link">Ignoring warnings for specific line of code</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#measuring-used-resource" class="nav-link">Measuring used resource</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#memory" class="nav-link">Memory</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#msvc" class="nav-link">MSVC</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#working-with-tabular-data" class="nav-link">Working with tabular data</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#executing-external-commands" class="nav-link">Executing external commands</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#command-line-interface" class="nav-link">Command Line Interface</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#jinja-like-templating" class="nav-link">Jinja-like Templating</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="3"><a href="#exceptions_1" class="nav-link">Exceptions</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="4"><a href="#render-errors" class="nav-link">Render Errors</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="source-and-header-files">Source and Header Files<a class="headerlink" href="#source-and-header-files" title="Permanent link">&para;</a></h1>
<p>In C++, there are:</p>
<ul>
<li>header files, that contain declarations of functions, classes, variables, etc. and, for templated code, the code itself.<ul>
<li>they have the <code>.h</code> or <code>.hpp</code> extension</li>
</ul>
</li>
<li>source files, that contain the definitions of the functions, classes, variables, etc.<ul>
<li>they have the <code>.cpp</code> extension</li>
</ul>
</li>
</ul>
<p>Each source file added to the target (see <a href="../CMake%20Manual/">CMake Manual</a> for adding source files to the target in CMake projects) is compiled into an object file - a <em>translation unit</em>. The header files are not compiled, but insted, they serve as a promise that there will be some translation unit that will contain the code that will be linked to the final executable. The above mechanism provides a flexible and practical interface, but a special care must be taken to avoid mistakes, that typically result in a liker error.</p>
<p>Most important here is the <a href="https://en.wikipedia.org/wiki/One_Definition_Rule"><em>One Definition Rule (ODR)</em></a>: each entity (e.g., class, function, variable, etc.) must be defined exactly once in the whole program.</p>
<ul>
<li>If something is defined in multiple translation units, it will result in a multiple definition error.</li>
<li>If we forgot to define some entity, or we do not add the source file with the definition to the target, it will result in an undefined reference error.</li>
</ul>
<p>Typically, each header has a corresponding source file, that contains the definition of all entities declared in the header. However, there is no requirement to have a single source file for each header, we can separate the code into multiple source files.</p>
<p>Note that <strong>all entities in the translation units added to the target are compiled, even if they are not used</strong>. This is in contrast with the statements inside functions, which are not compiled if they are not used.</p>
<h1 id="type-system">Type System<a class="headerlink" href="#type-system" title="Permanent link">&para;</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/type">cppreference</a></p>
<p><em>Type</em> is a property of each:</p>
<ul>
<li>object</li>
<li>reference</li>
<li>function</li>
<li>expression</li>
</ul>
<h2 id="complete-and-incomplete-types">Complete and Incomplete Types<a class="headerlink" href="#complete-and-incomplete-types" title="Permanent link">&para;</a></h2>
<p>In many context, we have to supply a type with a requirement of being a complete type. So what types are incomplete?</p>
<ul>
<li>The <code>void</code> type is always incomplete</li>
<li>Any structure without definition (e.g. using <code>struct structure *ps;</code>, without defining <code>structure</code>.)</li>
<li>An array without dimensions is an incomplete type: <code>int a[];</code> is incomplete, while <code>int a[5];</code> is complete.</li>
<li>An array of incomplete elements is incomplete.</li>
</ul>
<p>A type trait that can be used to determine whether a type is complete is described <a href="https://devblogs.microsoft.com/oldnewthing/20190710-00/?p=102678">here</a>.</p>
<h2 id="aggregate-types">Aggregate types<a class="headerlink" href="#aggregate-types" title="Permanent link">&para;</a></h2>
<p>Aggregate types are:</p>
<ul>
<li>array types</li>
<li>class types that fullfill the following conditions<ul>
<li>no private or protected members</li>
<li>no constructores declared (including inherited constructors)</li>
<li>no private or protected base classes</li>
<li>no virtual member functions</li>
</ul>
</li>
</ul>
<p>The elements of the aggregate types can and are ment to be constructed using the aggregate initialization (see the local variable initialization section).</p>
<h2 id="type-conversion">Type Conversion<a class="headerlink" href="#type-conversion" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">cppreference: implicit conversion</a></p>
<p>In some context, an implicit type conversion is aplied. This happens if we use a value of one type in a context that expects a different type. The conversion is applied automatically by the compiler, but it can be also applied explicitly using the <code>static_cast</code> operator. In some cases where the conversion is potentially dangerous, the <code>static_cast</code> is the only way to prevent compiler warnings.</p>
<h3 id="numeric-conversion">Numeric Conversion<a class="headerlink" href="#numeric-conversion" title="Permanent link">&para;</a></h3>
<p>There are two basic types of numeric conversion:</p>
<ul>
<li>
<p>standard <em>implicit conversion</em> that can be of many types: this conversion is applied if we use an expression of type <code>T</code> in a context that expects a type <code>U</code>. Example:
    ```cpp
    void print_int(int a){
        std::cout &lt;&lt; a &lt;&lt; std::endl;
    }</p>
<p>int main(){
    short a = 5;
    print_int(a); // a is implicitly converted to int
}
```</p>
</li>
<li>
<p><em>usual arithmetic conversion</em> which is applied when we use two different types in an arithmetic binary operation. Example:
    <code>cpp
    int main(){
        short a = 5;
        int b = 2;
        int c = a + b; // a is converted to int
    }</code></p>
</li>
</ul>
<h4 id="implicit-numeric-conversion">Implicit Numeric Conversion<a class="headerlink" href="#implicit-numeric-conversion" title="Permanent link">&para;</a></h4>
<h5 id="integral-promotion">Integral Promotion<a class="headerlink" href="#integral-promotion" title="Permanent link">&para;</a></h5>
<p>Integral promotion is a coversion of an integer type to a larger integer type. The promotion should be safe in a sense that it never changes the value. Important promotions are:</p>
<ul>
<li><code>bool</code> is promoted to <code>int</code>: <code>false</code> -&gt; <code>0</code>, <code>true</code> -&gt; <code>1</code></li>
</ul>
<h5 id="integral-conversion">Integral Conversion<a class="headerlink" href="#integral-conversion" title="Permanent link">&para;</a></h5>
<p>Unlike integral promotion, integral conversion coverts to a smaller type, so the value can be changed. The conversion is safe only if the value is in the range of the target type. Important conversions are:</p>
<h4 id="usual-arithmetic-conversion">Usual Arithmetic Conversion<a class="headerlink" href="#usual-arithmetic-conversion" title="Permanent link">&para;</a></h4>
<p><a href="https://en.cppreference.com/w/cpp/language/usual_arithmetic_conversions">cppreference</a></p>
<p>This conversion is applied when we use two different types in an arithmetic binary operation. The purpose of this conversion is convert both operands to the same type before the operation is applied. The result of the conversion is then the type of the operands. </p>
<p>The conversion has the following steps steps:</p>
<ol>
<li>lvalue to rvalue conversion of both operands</li>
<li>special step for enum types</li>
<li>special step for floating point types</li>
<li>conversion of both operands to the common type</li>
</ol>
<p>The last step: the conversion of both operands to the common type is performed using the following rules:</p>
<ol>
<li>If both operands have the same type, no conversion is performed.</li>
<li>If both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser <a href="https://en.cppreference.com/w/cpp/language/usual_arithmetic_conversions#Integer_conversion_rank">integer conversion rank</a> (size) is converted to the type of the operand with greater rank.</li>
<li>otherwise, we have a mix of signed and unsigned types. The following rules are applied:<ol>
<li>If the unsigned type has conversion rank greater or equal to the rank of the signed type, then the unsigned type is used.</li>
<li>Otherwise, if the signed type can represent all values of the unsigned type, then the signed type is used.</li>
<li>Otherwise, both operands are converted to the unsigned type corresponding to the signed type (same rank).</li>
</ol>
</li>
</ol>
<p>Here <strong>especially the rule 3.1 leads to many unexpected results</strong> and hard to find bugs. Example:</p>
<pre><code class="language-cpp">int main(){
    unsigned int a = 10;
    int b = -1;
    auto c = b - a; // c is unsigned and the value is 4294967285
}
</code></pre>
<p>To avoid this problem, <strong>always use the <code>static_cast</code> operator if dealing with mixed signed/unsigned types</strong>.</p>
<h2 id="show-the-type-at-runtime">Show the Type at Runtime<a class="headerlink" href="#show-the-type-at-runtime" title="Permanent link">&para;</a></h2>
<p>It may be useful to show the type of a variable at runtime:</p>
<ul>
<li>for debugging purposes</li>
<li>for logging</li>
<li>to compare the types of two variables</li>
</ul>
<p>Note however, that in C++, there is no reflection support. Therefore, <strong>we cannot retrieve the name of the type at runtime in a reliable way</strong>. Instead, the name retrieved by the methods described below can depend on the compiler and the compiler settings.</p>
<h3 id="resolved-complicated-types">Resolved complicated types<a class="headerlink" href="#resolved-complicated-types" title="Permanent link">&para;</a></h3>
<p>Sometimes, it is useful to print the type, so that we can see the real type of some complicated template code. For that, the following template can be used:</p>
<pre><code class="language-cpp">#include &lt;string_view&gt;

template &lt;typename T&gt;
constexpr auto type_name() {
  std::string_view name, prefix, suffix;
#ifdef __clang__
  name = __PRETTY_FUNCTION__;
  prefix = &quot;auto type_name() [T = &quot;;
  suffix = &quot;]&quot;;
#elif defined(__GNUC__)
  name = __PRETTY_FUNCTION__;
  prefix = &quot;constexpr auto type_name() [with T = &quot;;
  suffix = &quot;]&quot;;
#elif defined(_MSC_VER)
  name = __FUNCSIG__;
  prefix = &quot;auto __cdecl type_name&lt;&quot;;
  suffix = &quot;&gt;(void)&quot;;
#endif
  name.remove_prefix(prefix.size());
  name.remove_suffix(suffix.size());
  return name;
}
</code></pre>
<p>Usage:</p>
<pre><code class="language-cpp">std::cout &lt;&lt; type_name&lt;std::remove_pointer_t&lt;typename std::vector&lt;std::string&gt;::iterator::value_type&gt;&gt;() &lt;&lt; std::endl;

// Prints: class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;
</code></pre>
<p><a href="https://stackoverflow.com/a/56766138/1827955">Source on SO</a></p>
<h3 id="show-the-user-provided-types-stdtype_info">Show the user-provided types (std::type_info)<a class="headerlink" href="#show-the-user-provided-types-stdtype_info" title="Permanent link">&para;</a></h3>
<p>If we want to show the type of a variable provided by the user (e.g., by a function accepting <code>std::any</code>), we can use the <a href="https://en.cppreference.com/w/cpp/language/typeid"><code>typeid</code></a> operator which returns a <a href="https://en.cppreference.com/w/cpp/types/type_info"><code>std::type_info</code></a> object.  </p>
<h1 id="built-in-and-stl-types">Built-in and STL Types<a class="headerlink" href="#built-in-and-stl-types" title="Permanent link">&para;</a></h1>
<h2 id="arithmetic-types">Arithmetic Types<a class="headerlink" href="#arithmetic-types" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/types">cppreference</a></p>
<h3 id="integers">Integers<a class="headerlink" href="#integers" title="Permanent link">&para;</a></h3>
<p>Integer types varies in the sign and size.</p>
<p>Unfortunatelly, <strong>the minimum sizes guaranteed by the standard are not usable, because the real size is different and it differs even between platforms</strong>. Especially the <code>long</code> type. To use an integer with a specific size, or a specific minimal size, we can use <a href="https://en.cppreference.com/w/cpp/types/integer">type aliases defined in <code>cstdint</code></a></p>
<h3 id="overflow-and-underflow">Overflow and Underflow<a class="headerlink" href="#overflow-and-underflow" title="Permanent link">&para;</a></h3>
<p>The overflow (and underflow) is a common problem in most programming languages. The problem in C++ is that:</p>
<ul>
<li>overflows are <strong>not detected</strong></li>
<li>overflows can happen in many unexpected situations</li>
</ul>
<h4 id="dangerous-situations">Dangerous situations<a class="headerlink" href="#dangerous-situations" title="Permanent link">&para;</a></h4>
<p>In addition to the usual suspects like assigning a value to a variable of a smaller type, there are some less obvious situations that can cause overflows. Some examples:</p>
<ul>
<li>the result of an arithmetic operation is assigned to a variable of large enough type, but the overflow happens before the assignment itself:
    <code>cpp
    short a = 32767;
    short b = 1;
    int c = a + b; // overflow happens beffore the assignment</code>
    A solution to this problem is to use a numeric cast of the opperands (even one is enouhg):
    <code>cpp
    short a = 32767;
    short b = 1;
    int c = static_cast&lt;int&gt;(a) + b;</code></li>
</ul>
<h4 id="detecting-overflows">Detecting overflows<a class="headerlink" href="#detecting-overflows" title="Permanent link">&para;</a></h4>
<p>There are some methods how to detect overflows automatically by suppliying arguments to the compiler. These are summarized here:</p>
<ul>
<li><strong>MSVC</strong>: not implemented</li>
<li><strong>GCC</strong>: only detectes signed and floating point overflows, as the unsigned overflows are not considered as errors (the behaviour is defined in the standard). All undefined behaviour can be detected using the <code>-fsanitize=undefined</code> flag. <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html">Documentation</a></li>
<li><strong>Clang</strong>: Both signed and unsigned overflow can be detected. The undefined behaviour can be detected using the <code>-fsanitize=undefined</code> flag. Fo all integer overflows, the <code>-fsanitize=integer</code> flag can be used. <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Documentation</a></li>
</ul>
<p>The reasoning behind excluding the unsigned overflows from GCC are described <a href="https://gcc.gnu.org/legacy-ml/gcc/2016-07/msg00051.html">here</a>.</p>
<p>It is also possible to do an ad-hoc overflow check in the code, the possible solutions are described in <a href="https://stackoverflow.com/questions/199333/how-do-i-detect-unsigned-integer-overflow">this SO question</a></p>
<h3 id="characters">Characters<a class="headerlink" href="#characters" title="Permanent link">&para;</a></h3>
<p>Characters in C++ are represented by the <code>char</code> type, which is an integer type. This type can be signed or unsigned, and it is at least 8 bits long. </p>
<p>Useful functions for working with characters are:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/string/byte/isspace"><code>std::isspace</code></a>: checks if the character is a whitespace (space, tab, newline, etc.)</li>
<li><a href="https://en.cppreference.com/w/cpp/string/byte/toupper"><code>std::toupper</code></a>: converts the character to upper case</li>
</ul>
<h2 id="pointers">Pointers<a class="headerlink" href="#pointers" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/pointer">cppreference</a></p>
<h3 id="pointers-to-functions">Pointers to Functions<a class="headerlink" href="#pointers-to-functions" title="Permanent link">&para;</a></h3>
<p>Function pointers are declared as:</p>
<pre><code class="language-cpp">&lt;return_type&gt; (*&lt;pointer_name&gt;)(&lt;arg_1_type&gt;, ..., &lt;arg_n_type&gt;)
</code></pre>
<p>For example a function <code>the_function</code> returning bool and accepting int can be stored to pointer like this:</p>
<pre><code class="language-C++">bool (*ptr)(int) = &amp;the_function
</code></pre>
<p>The above example can be then simply called as <code>bool b = ptr(2)</code></p>
<h3 id="pointers-to-member-objects">Pointers to Member Objects<a class="headerlink" href="#pointers-to-member-objects" title="Permanent link">&para;</a></h3>
<p>Pointers to member objects has a cumbersome syntax</p>
<ul>
<li>declaration: <code>&lt;member type&gt; &lt;class type&gt;::*&lt;pointer name&gt; = ...</code></li>
<li>usage: <code>&lt;object name&gt;.*&lt;pointer name&gt; = ...</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-cpp">class My_class{
public:
    int my_member;
}

int main{
    // declaring the pointer
    int My_class::*ptr = &amp;My_class::my_member;

    // creating the instance
    My_class inst;

    // using the pointer to a member object
    inst.*ptr = 2;
}
</code></pre>
<h3 id="pointers-to-member-functions">Pointers to Member Functions<a class="headerlink" href="#pointers-to-member-functions" title="Permanent link">&para;</a></h3>
<p>Pointers to member functions are even more scary in C++. We need to use the member object and the function adress and combine it in a obscure way:</p>
<pre><code class="language-cpp">class My_class{
public:
    bool my_method(int par);    
}

int main{
    // creating the instance
    My_class inst;

    // assigning method address to a pointer
    bool (My_class::*ptr)(int) = &amp;My_class::my_method;

    // using the pointer to a member function
    bool b = (inst.*ptr)(2)
}
</code></pre>
<p>The first unexpected change is the <code>My_class</code> before the name of the pointer. It's because unlike a pointer to function <code>the_function</code> which is of type <code>(*)(int)</code>, the pointer to <code>my_method</code> is of type <code>(My_class::*)(int)</code></p>
<p>The second difference is the call. We have t use the pointer to member binding operator <code>.*</code> to access the member of the specific instance  <code>inst</code>. But this operator has a lower priority then the function call operator, so we must use the extra parantheses.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/reference">References</a> serve as an alias to already existing objects. Standard (<em>Lvalue</em>) references works the same way as pointers, with two differences:</p>
<ul>
<li>they cannot be NULL</li>
<li>they cannot be reassigned</li>
</ul>
<p>The second property is the most important, as the assignment is a common operation, which often happens under do hood. In conslusion, <strong>reference types cannot be used in most of the containers and objets that needs to be copied</strong>.</p>
<h3 id="rvalue-references">Rvalue references<a class="headerlink" href="#rvalue-references" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/reference#Rvalue_references">Rvalue references</a> are used to refer to temporary objects. They eneable to prevent copying local objets by extending lifetime of temporary objects. They are mostly used as function parameters:</p>
<pre><code class="language-cpp">void f(int&amp; x){
}

f(3); // 3 needs to be copied to f, because it is a temporary variable
 
// we can add the rvalue overload
void f(int&amp;&amp; x){
}

f(3) // rvalue overload called, no copy
</code></pre>
<h3 id="forwarding-references">Forwarding references<a class="headerlink" href="#forwarding-references" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">Forwarding references</a> are references that preserves the value category (i.e. r/l-value reference, <code>const</code>). They have two forms:</p>
<ul>
<li>function parameter forwarding references</li>
<li><code>auto</code> forwarding references</li>
</ul>
<h4 id="function-parameter-forwarding-references">Function parameter forwarding references<a class="headerlink" href="#function-parameter-forwarding-references" title="Permanent link">&para;</a></h4>
<p>In a function template, if we use the rvalue reference syntax for a function parameter of  whose type is a function template parameter, the reference is actually a forwarding reference. Example:</p>
<pre><code class="language-cpp">template&lt;class T&gt;
void f(T&amp;&amp; arg) // parameter is T&amp; or T&amp;&amp; depending on the supplied argument
</code></pre>
<p>Important details:</p>
<ul>
<li>it works only for non const references</li>
<li>the reference type has to be a function template argument, not a class template argument </li>
</ul>
<h4 id="auto-forwarding-reference"><code>auto</code> forwarding reference<a class="headerlink" href="#auto-forwarding-reference" title="Permanent link">&para;</a></h4>
<p>When we assign to `auto&amp;&amp;, it is a forwarding reference, not rvalue reference:</p>
<pre><code class="language-cpp">auto&amp;&amp; a = f() // both type and value category depends on the return value of f()

for(auto&amp;&amp; a: g(){ // same
}
</code></pre>
<h2 id="arrays">Arrays<a class="headerlink" href="#arrays" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/array">cppreference</a></p>
<p>There are two types of arrays:</p>
<ul>
<li><em>static</em>, i.e., their size is known at compile type, and</li>
<li><em>dynamic</em>, the size of which is computed at runtime</li>
</ul>
<p>We can use the array name to access the first elemnt of the array as it is the pointer to that element.</p>
<h3 id="static-arrays">Static arrays<a class="headerlink" href="#static-arrays" title="Permanent link">&para;</a></h3>
<p>Declaration:</p>
<pre><code class="language-cpp">int a[nrows];
int a[nrwows][ncols]; // 2D
int a[x_1]...[x_n]; // ND 
</code></pre>
<p>Initialization:</p>
<pre><code class="language-cpp">int a[3] = {1, 2, 5}
int b[3] = {} // zero initialization
int c[3][2] = {{1,5}, {2,9}, {4,4}} // 2D
int d[] = {1,5} // we can skip dimensions if their can be derived from data
</code></pre>
<p>Note that  the multi-dimensional syntax is just an abstraction for the programmers. The following code blocks are therefore equivalent:</p>
<p>Matrix syntax</p>
<pre><code class="language-cpp">const int rowns = 5;
const int cols =  3;
int matrix[rows][cols];

int main(){
    for(int n = 0; n &lt; rows; ++n){
        for(int m = 0; m &lt; cols; ++m){  
            Table[n][m] = (n + 1) * (m + 1);
        }
    }
}
</code></pre>
<p>Flat syntax</p>
<pre><code class="language-cpp">const int rowns = 5;
const int cols =  3;
int matrix[rows * cols];

int main(){
    for(int n = 0; n &lt; rows; ++n){
        for(int m = 0; m &lt; cols; ++m){  
            Table[n * cols + m] = (n + 1) * (m + 1);
        }
    }
}
</code></pre>
<p>Using the matrix syntax adds the possibility to access the element of the array using multiple dimensions. But the underlying memory is the same.</p>
<h3 id="dynamic-arrays">Dynamic arrays<a class="headerlink" href="#dynamic-arrays" title="Permanent link">&para;</a></h3>
<p>Declaration:</p>
<pre><code class="language-cpp">int* a = new int[size]
</code></pre>
<p>For multiple dimensions, this syntax does not scale, i.e, only one dimension can be dynamic:</p>
<pre><code class="language-cpp">int(*a)[4] = new int[rows][4] // static column count
int(*b)[cols] = new int[rows][cols] // does not compile unless cols is a constant!
</code></pre>
<h3 id="array-to-pointer-implicit-conversion">Array to pointer implicit conversion<a class="headerlink" href="#array-to-pointer-implicit-conversion" title="Permanent link">&para;</a></h3>
<p>When we use the array name in an expression, it can be implicitly converted to a pointer to the first element of the array. This is true for both static and dynamic arrays. Example:</p>
<pre><code class="language-cpp">int a[3] = {1, 2, 5}
int* ptr = a; // ptr points to the first element of a
</code></pre>
<p>This implicit conversion is called <em>array-to-pointer decay</em>.</p>
<h3 id="mutli-dimensional-dynamic-arrays">Mutli-dimensional dynamic arrays<a class="headerlink" href="#mutli-dimensional-dynamic-arrays" title="Permanent link">&para;</a></h3>
<p>To simulate multi-dimensional dynamic arrays, we have two options:</p>
<ul>
<li>use the flat syntax, as demonstrated on static arrays</li>
<li>use aray of pointers to arrays </li>
</ul>
<table>
<thead>
<tr>
<th>Method</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Flat Syntax</td>
<td>Fast: single continuous allocations</td>
<td>different access syntax than static 2D arrays</td>
</tr>
<tr>
<td>Array of pointers</td>
<td>Slow: one allocation per row, unrelated memory addresses between rows</td>
<td>same access syntax as static 2D arrays</td>
</tr>
</tbody>
</table>
<h4 id="flat-array">Flat array<a class="headerlink" href="#flat-array" title="Permanent link">&para;</a></h4>
<pre><code class="language-cpp">int* a = new int[rows * cols]
</code></pre>
<p>Then we can access the array as:</p>
<pre><code class="language-cpp">a[x * cols + y] = 5
</code></pre>
<h4 id="array-of-pointers-to-array">Array of pointers to array<a class="headerlink" href="#array-of-pointers-to-array" title="Permanent link">&para;</a></h4>
<p>Declaration and Definition</p>
<pre><code class="language-cpp">int** a= new int*[rows]

for(int i = 0; i &lt; rows; ++i){
    a[i] = new int[cols]
}
</code></pre>
<p>Access is than like for static 2D array: <code>a[x][y] = 5</code>. This works because the pointers can be also accessed using the array index operator (<code>[]</code>). In other words, it works "by coincidence", but we have not created a real 2D array.</p>
<h3 id="auto-dealocation-of-dynamic-arrays">Auto dealocation of dynamic arrays<a class="headerlink" href="#auto-dealocation-of-dynamic-arrays" title="Permanent link">&para;</a></h3>
<p>We can replace the error-prone usage of <code>new</code> and <code>delete</code> by wraping the array into unique pointer:</p>
<pre><code class="language-cpp">std:unique_ptr&lt;int[]&gt; a;
a = std::make_unique&lt;int[]&gt;(size)
</code></pre>
<h2 id="references-and-pointers-to-arrays">References and Pointers to arrays<a class="headerlink" href="#references-and-pointers-to-arrays" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/pointer">cppreference</a></p>
<p>The pointer to array is declared as <code>&lt;type&gt; (*&lt;pointer_name&gt;)[&lt;size&gt;]</code>:</p>
<pre><code class="language-cpp">int a[5];
int (*ptr)[5] = &amp;a;
</code></pre>
<p>Analogously, the reference to array is declared as <code>&lt;type&gt; (&amp;&lt;reference_name&gt;)[&lt;size&gt;]</code>:</p>
<pre><code class="language-cpp">int a[5];
int (&amp;ref)[5] = a;
</code></pre>
<h2 id="function-type">Function Type<a class="headerlink" href="#function-type" title="Permanent link">&para;</a></h2>
<p>A function type consist from the function arguments and the return type. The function type is written as <code>return_type(arg_1_type, ..., arg_n_type)</code>. Example:</p>
<pre><code class="language-cpp">int foo(double a, double b);

static_assert(std::is_same_v&lt;decltype(foo), int(double, double)&gt;) // TRUE
</code></pre>
<h2 id="reference-to-function-and-pointer-to-function-types">Reference to Function and Pointer to Function Types<a class="headerlink" href="#reference-to-function-and-pointer-to-function-types" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/pointer">cppreference</a></p>
<p>A refrence to function has a type <code>return_type(&amp;)(arg_1_type, ..., arg_n_type)</code>. Example:</p>
<pre><code class="language-cpp">int foo(double a, double b);
static_assert(std::is_same_v&lt;decltype(foo)&amp;, int(&amp;)(double, double)&gt;); // TRUE
</code></pre>
<p>A pointer to function has a type: <code>return_type(*)(arg_1_type, ..., arg_n_type)</code>Example:</p>
<pre><code class="language-cpp">int foo(double a, double b);
static_assert(std::is_same_v&lt;decltype(foo)*, int(*)(double, double)&gt;); // TRUE
</code></pre>
<h2 id="enumerations">Enumerations<a class="headerlink" href="#enumerations" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/enum">cppreference</a></p>
<p>C++ supports simple enumerations, which are a set of named integer constants. The enumeration can be defined as:</p>
<pre><code class="language-cpp">enum Color {red, green, blue}; // global scope

enum class Color {red, green, blue}; // scoped, preferred
</code></pre>
<p>There is no support for enum members like in Python, but we can use a wrapper class for that:</p>
<pre><code class="language-cpp">class Color{
public:
    enum Value {red, green, blue};

    Color(Value v): value(v){} // non-explicit constructor for easy initialization

    Value get_value() const {return value;}

    std::string to_string() const{
        switch(value){
            case Value::red: return &quot;red&quot;;
            case Value::green: return &quot;green&quot;;
            case Value::blue: return &quot;blue&quot;;
        }
    }

private:
    Value value;
}

Color get_color(){
    return Color::red; // this works due to the non-explicit constructor
}

int main(){
    Color c = get_color();
    std::cout &lt;&lt; c.to_string() &lt;&lt; std::endl;

    switch(c.get_value()){
        case Color::red: std::cout &lt;&lt; &quot;red&quot; &lt;&lt; std::endl;
        case Color::green: std::cout &lt;&lt; &quot;green&quot; &lt;&lt; std::endl;
        case Color::blue: std::cout &lt;&lt; &quot;blue&quot; &lt;&lt; std::endl;
    }
}
</code></pre>
<p>For more complex code requireing automatic conversion to string and more, we can consider the <a href="https://github.com/Neargye/magic_enum">magic_enum library</a>. It supports the following features:</p>
<ul>
<li>enum to string conversion</li>
<li>string to enum conversion</li>
<li>enum iteration</li>
<li>sequence of possible values</li>
</ul>
<h2 id="smart-pointers">Smart Pointers<a class="headerlink" href="#smart-pointers" title="Permanent link">&para;</a></h2>
<p>For managing resources in dynamic memory, <em>smart pointers</em> (sometimes called <em>handles</em>) should be used. They manage the memory (alocation, dealocation) automatically, but their usage requires some practice.</p>
<p>There are two types of smart pointers:</p>
<ul>
<li><code>std::unique_ptr</code> for unique ownership</li>
<li><code>std::shared_ptr</code> for shared ownership</li>
</ul>
<h3 id="creation">Creation<a class="headerlink" href="#creation" title="Permanent link">&para;</a></h3>
<p>Usually, we create the pointer together with the target object in one call:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique"><code>std::make_unique&lt;T&gt;(&lt;OBJECT PARAMS&gt;)</code></a> for unique pointer</li>
<li><code>std::make_shared&lt;T&gt;(&lt;OBJECT PARAMS&gt;)</code> for shared pointer</li>
</ul>
<p>These methods work well for objects, but cannot be used for arbitrary array initialization (only the empty/zero-initialized array can be created using these methods). For arbitrary array initialization, we need to use the smart pointer constructor:</p>
<pre><code class="language-cpp">std::unique_ptr&lt;int[]&gt; ptr(new int[]{1, 2, 3}); 
</code></pre>
<p>Counter-intuitively, smart pointers created using the empty constructor of the respective pointer type does not default-construct the target object, but initialize the pointer to null instead:</p>
<pre><code class="language-cpp">std::unique_ptr&lt;My_class&gt; ptr(std::null_ptr); // ptr is null
std::unique_ptr&lt;My_class&gt; ptr(); // ptr is also null
</code></pre>
<h3 id="shared-pointer">Shared Pointer<a class="headerlink" href="#shared-pointer" title="Permanent link">&para;</a></h3>
<p>Pointer to object with non-trivial ownership (owned by multiple objects).</p>
<h2 id="stdreference_wrapper">std::reference_wrapper<a class="headerlink" href="#stdreference_wrapper" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper">cppreference</a>
Reference wrapper is a class template that can be used to store references in containers or aggregated objects. The disintinction from normal references is that the reference wrapper can be copied and assigned, so it does not prevent the copy/move operations on the object it belongs to. Otherwise, it behaves like a normal reference: it has to be assigned to a valid object and it cannot be null.</p>
<h2 id="strings">Strings<a class="headerlink" href="#strings" title="Permanent link">&para;</a></h2>
<p>In C++, there are two types of strings:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a> is an owning class for a string.</li>
<li><a href="https://en.cppreference.com/w/cpp/string/basic_string_view"><code>std::string_view</code></a> is a non-owning class for a string.</li>
</ul>
<p>Also, there is a C-style string (<code>char*</code>), but it is not recommended to use it in modern C++.</p>
<p>The difference between <code>std::string</code> and <code>std::string_view</code> is best explained by a table below:</p>
<table>
<thead>
<tr>
<th></th>
<th><code>std::string</code></th>
<th><code>std::string_view</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Owning</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Null-terminated</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Size</strong></td>
<td>Dynamic</td>
<td>Static</td>
</tr>
<tr>
<td><strong>Lifetime</strong></td>
<td>Managed by the string</td>
<td>Managed by the underlying char sequence</td>
</tr>
<tr>
<td><strong>Can be <code>constexpr</code></strong></td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>and the following code:</p>
<pre><code class="language-cpp">std::string_view sv = &quot;hello&quot;; // sv is a view of the string literal &quot;hello&quot;
std::string s = &quot;hello&quot;; // s stores a copy of the string literal &quot;hello&quot;
</code></pre>
<h3 id="string-literals">String Literals<a class="headerlink" href="#string-literals" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/string_literal">cppreference</a></p>
<p>The standard string literal is writen as <code>"literal"</code>. However, we need to escape some <strong>special characters</strong> in such literals, therefore, a <em>raw string</em> literal is sometimes more desirable: <code>R"(literal)"</code>.</p>
<p>If our literal contains <code>(</code> or <code>)</code>, this is stil not enough, however, the delimiter can be extended to any string with a maximum length of 16 characters, for example:
 <code>R"lit(literal)lit"</code>. </p>
<p>Raw string literals also useful for <strong>multi-line string literals</strong>.</p>
<h3 id="formatting-strings">Formatting strings<a class="headerlink" href="#formatting-strings" title="Permanent link">&para;</a></h3>
<p>The usage of modern string formating is either</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/format/format"><code>std::format</code></a> from the <code>&lt;format&gt;</code> header if the compiler supports <a href="https://en.cppreference.com/w/cpp/utility/format">C++20 string formatting</a> (<a href="https://en.cppreference.com/w/cpp/compiler_support">compiler support</a>) or</li>
<li><code>fmt::format</code> from the <a href="https://github.com/fmtlib/fmt"><code>fmt</code></a> library if not.</li>
</ul>
<p>Either way, the usage is the same:</p>
<pre><code class="language-cpp">format(&lt;literal&gt;, &lt;arguments&gt;)
</code></pre>
<p>where the literal is a string literal with <code>{}</code> placeholders and the arguments are the values to be inserted into the placeholders. </p>
<p>The placeholders can be filled width  </p>
<ul>
<li>argument identification, if we want to use the same argument multiple times or change the order in the string while keep the order of arguments in the function call or</li>
<li>format specification.</li>
</ul>
<p>These two parts are separated by <code>:</code>, both of them are optional.</p>
<p>The most common format specifications are:</p>
<ul>
<li>data type:<ul>
<li><code>d</code> for decimal integer</li>
<li><code>f</code> for floating point number</li>
<li><code>s</code> for string</li>
</ul>
</li>
<li>width and precision, in the format <code>&lt;width&gt;.&lt;precision&gt;</code>. Both values can be dynamic: <code>std::format("{:{}.{}f}", a, b, c)</code> formats a float number <code>a</code> with width <code>b</code> and precision <code>c</code>.</li>
</ul>
<p>The formating reference can be found in the <a href="https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification">cppreference</a> </p>
<h3 id="spliting-the-string-into-tokens">Spliting the string into tokens<a class="headerlink" href="#spliting-the-string-into-tokens" title="Permanent link">&para;</a></h3>
<p>Unfortunately, the STL does not provide a simple way to split the string into tokens like Python's <code>split</code> method or PHP's <code>explode</code> function. It is not even planned for the future.  </p>
<p>If we want to split a string on a character or pattern, the easiest way is to use the <a href="https://en.cppreference.com/w/cpp/ranges/split_view">split view</a> from the ranges library, which has a <a href="https://en.cppreference.com/w/cpp/ranges/subrange"><code>std::ranges::subrange</code></a> as its element type: </p>
<pre><code class="language-cpp">// get a range of character subranges
auto parts = std::ranges::views::split(str, '-');

// iterate over the parts
for (auto part : parts) {
    std::cout &lt;&lt; part &lt;&lt; std::endl; // prints the part

    // convert part to string
    std::string s(part.begin(), part.end());

    // convert part to string (C++23)
    std::string s(std::from_range, part);
}
</code></pre>
<p>The last <a href="https://en.cppreference.com/w/cpp/string/basic_string/basic_string">string constructor</a> is only available in C++23, and moreover, it requires the <a href="https://en.cppreference.com/w/cpp/ranges/from_range"><code>stl::from_range</code></a> tag. The <code>std::string_view</code> is equiped with a range constructor which does not require the tag in C++23. However, it is explicit, so its usage is limited:</p>
<pre><code class="language-cpp">std::string_view s(part) // invalid
std::string_view s = std::string_view(part) // valid in C++23
</code></pre>
<h3 id="converting-string-to-int">Converting string to int<a class="headerlink" href="#converting-string-to-int" title="Permanent link">&para;</a></h3>
<p>There are simple functions for converting <code>std::string</code> to numbers, named <code>std::stoi</code>, <code>std::stoul</code>, etc. See <a href="https://en.cppreference.com/w/cpp/string/basic_string">cppreference</a> for details.</p>
<p>For C strings, the situation is more complicated.</p>
<h3 id="substring">Substring<a class="headerlink" href="#substring" title="Permanent link">&para;</a></h3>
<p>A substring can be obtained using a member function <code>substr</code>:</p>
<pre><code class="language-cpp">str.substr(str.size() - 1, 1)) // returns the last character as a string
</code></pre>
<h3 id="change-the-case">change the case<a class="headerlink" href="#change-the-case" title="Permanent link">&para;</a></h3>
<p>Unfortunatelly, the STL has case changing functions only for characters, so we need to iterate over the string ourselfs. The boost has a solution, however:</p>
<pre><code class="language-cpp">#include &lt;boost/algorithm/string.hpp&gt;

auto upper = boost::to_upper(str);
</code></pre>
<h3 id="building-strings">Building strings<a class="headerlink" href="#building-strings" title="Permanent link">&para;</a></h3>
<p>Unlike other languages, in C++, strings are mutable, so we can build them using the <code>+</code> operator without performance penalty. Alternatively, we can use the <code>std::stringstream</code> class.</p>
<h3 id="testting-for-whitespace">Testting for whitespace<a class="headerlink" href="#testting-for-whitespace" title="Permanent link">&para;</a></h3>
<p>To test if a string contains only whitespace characters, we can use the <code>std::all_of</code> algorithm:</p>
<pre><code class="language-cpp">std::all_of(str.begin(), str.end(), [](char c){return std::isspace(c);})
</code></pre>
<h2 id="date-and-time">Date and time<a class="headerlink" href="#date-and-time" title="Permanent link">&para;</a></h2>
<p>The date and time structure in C++ is <a href="https://en.cppreference.com/w/cpp/chrono/c/tm"><code>std::tm</code></a>. We can create it from the date and time string using <a href="https://en.cppreference.com/w/cpp/io/manip/get_time"><code>std::get_time</code></a> function:</p>
<pre><code class="language-cpp">std::tm tm;
std::istringstream ss(&quot;2011-Feb-18 23:12:34&quot;);
ss &gt;&gt; std::get_time(&amp;tm, &quot;%Y-%b-%d %H:%M:%S&quot;);
</code></pre>
<h2 id="collections">Collections<a class="headerlink" href="#collections" title="Permanent link">&para;</a></h2>
<p>In C++, the collections are implemented as templates, so they can store any type. The most common collections are:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/container/array">std::array</a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/unordered_set">std::unordered_set</a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/unordered_map">std::unordered_map</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/pair">std::pair</a> and <a href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a></li>
</ul>
<p>Currently, the collection semantic requirmenets are not imposed on the whole connection, bu on its member functions instead. Depending on the function used, there are different requirements for the stored types. This adds a lot of flexibility, as we can, for example, use move only types in collections when we refrain from using functions that require copying. On the other hand, it can make the debugging harder, as the compiler usually does not recognize the methods that caused the template to have stricter requirements but instead complains on the place where the template is instantiated.</p>
<h3 id="sets">Sets<a class="headerlink" href="#sets" title="Permanent link">&para;</a></h3>
<p>Normal set collection for C++ is <a href="https://en.cppreference.com/w/cpp/container/unordered_set"><code>std::unordered_set</code></a>. By default, the set uses a <code>Hash</code>, <code>KeyEqual</code> and <code>Allocator</code> template params provided by std functions. However, they need to exist, specifically:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/hash"><code>std::hash&lt;Key&gt;</code></a></li>
<li><code>std::equal_to&lt;Key&gt;</code></li>
<li><code>std::allocator&lt;Key&gt;</code></li>
</ul>
<p>So either those specializations needs to be provided by the snadard library (check cppreference), or you have to provide it. </p>
<h4 id="providing-custom-hash-function">Providing custom hash function<a class="headerlink" href="#providing-custom-hash-function" title="Permanent link">&para;</a></h4>
<p>There are two options for providing custom hash function for a type <code>T</code>s:</p>
<ul>
<li>implementing an <em>explicit specialization</em> of the template function  <code>std::hash&lt;T&gt;</code></li>
<li>providing the <code>Hash</code> template param when constructing the hash</li>
</ul>
<p>The first method is prefered if we want to provide a default hash function for some type for which there is no hash function specialization in the standard library. The second method is prefered only when we want some special hash function for a type <code>T</code> for which <code>std::hash&lt;T&gt;</code> is already defined.</p>
<h4 id="implementing-custom-hash-function">Implementing custom hash function<a class="headerlink" href="#implementing-custom-hash-function" title="Permanent link">&para;</a></h4>
<p>First check whether the hash function is not provide by STL on <a href="https://en.cppreference.com/w/cpp/utility/hash">cppreference</a>. Then, many other hash specializations are implemented by boost, check the <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/hash/reference.html">reference</a>. </p>
<p>If there is no implementation, we can implement the hash function as follows (example for set):</p>
<pre><code class="language-cpp">template&lt;&gt;
struct std::hash&lt;std::unordered_set&lt;const Request*&gt;&gt; {
    size_t operator()(const std::unordered_set&lt;const Request*&gt;&amp; set) const {
        std::hash&lt;const Request&gt; hash_f;
        size_t sum{0};
        for (const Request* r : set) {
            sum += hash_f(*r);
        }
        return sum;
    }
};
</code></pre>
<p>Important implementation details:</p>
<ul>
<li>the function needs to be implemented inside <code>std</code> or annonymous namespace, not inside a custom namespace</li>
<li>do not forget to add <code>template&lt;&gt;</code> above the function, this indicates that it is a template specialization.</li>
</ul>
<h3 id="maps">Maps<a class="headerlink" href="#maps" title="Permanent link">&para;</a></h3>
<p>The maps has similar requiremnts for keys as the requirements for set value types (see previous section). The hash map type is called <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a>. Note that <a href="https://stackoverflow.com/a/74965248/1827955">maps require the stored types to be complete</a>.</p>
<h4 id="geeting-value-by-key">Geeting value by key<a class="headerlink" href="#geeting-value-by-key" title="Permanent link">&para;</a></h4>
<p>To access the map element, the array operator (<code>[]</code>) can be used. Note however, that this operator does not check the existence of the key, even if we do not provide a value. Example:</p>
<pre><code class="language-cpp">std::unordered_map&lt;int,std::string&gt; map;
map[0] = &quot;hello&quot;
map[0] = &quot;world&quot; // OK, tha value is overwritten
a = map[1] // a == map[1] == &quot;&quot; unintuitively, the default value is inserted if the key does not exist
</code></pre>
<p>Therefore, <strong>if we just read from the map, it is safer to use the <code>at()</code></strong> member function.</p>
<h4 id="inserting-into-map">Inserting into map<a class="headerlink" href="#inserting-into-map" title="Permanent link">&para;</a></h4>
<p>There are five options:</p>
<ol>
<li><a href="https://en.cppreference.com/w/cpp/container/unordered_map/operator_at"><code>map[key] = value;</code></a> or</li>
<li><a href="https://en.cppreference.com/w/cpp/container/unordered_map/emplace"><code>map.insert({key, value})</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/unordered_map/emplace"><code>map.emplace(key, value);</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/unordered_map/try_emplace"><code>map.try_emplace(key, value);</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/container/unordered_map/insert_or_assign"><code>map.insert_or_assign(key, value);</code></a></li>
</ol>
<p>The following table summarizes the differences:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>If key exists</th>
<th>constructs in place</th>
<th>returns value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>map[key] = value;</code></td>
<td>overwrites</td>
<td>no</td>
<td>a reference to the value</td>
</tr>
<tr>
<td><code>map.insert({key, value});</code></td>
<td>does not overwrite</td>
<td>no</td>
<td>a pair of iterator to value and bool set to true if insertion took place</td>
</tr>
<tr>
<td><code>map.emplace(key, value);</code></td>
<td>does not overwrite</td>
<td>yes</td>
<td>a pair of iterator to value and bool set to true if insertion took place</td>
</tr>
<tr>
<td><code>map.try_emplace(key, value);</code></td>
<td>does not overwrite</td>
<td>yes</td>
<td>same as emplace</td>
</tr>
<tr>
<td><code>map.insert_or_assign(key, value);</code></td>
<td>overwrites</td>
<td>yes</td>
<td>a pair of iterator to value and bool set to true if insertion took place</td>
</tr>
</tbody>
</table>
<p>There is only a small difference between <code>emplace</code> and <code>try_emplace</code>: the <code>try_emplace</code> does not create a new value if the key already exists, while the <code>emplace</code> can create a new value even if the key already exists (in which case, the value is then discarded).</p>
<h3 id="tuples">Tuples<a class="headerlink" href="#tuples" title="Permanent link">&para;</a></h3>
<p>We have two standard class templates for tuples:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/pair"><code>std::pair</code></a> for pairs</li>
<li><a href="https://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a> for tuples with unlimited size</li>
</ul>
<p>Although named differently, these class templates behaves mostly the same.</p>
<h4 id="creating-tuples">Creating tuples<a class="headerlink" href="#creating-tuples" title="Permanent link">&para;</a></h4>
<p>There are two ways of creating a tuple:</p>
<ul>
<li>constructor (<code>auto p = std::pair(...)</code>)</li>
<li>initializer (<code>auto p = {}</code>)</li>
</ul>
<p>Beware that <strong>by default</strong>, the deduced types are decayed, i.e., const and references are removed and the <strong>tuple stores value types</strong>. If you need to store the reference in a tuple, you have to specify the type: </p>
<pre><code class="language-cpp">auto p = std::pair&lt;int, constr std::string&amp;&gt;(...)
</code></pre>
<p>Also, beware that the RVO does not apply for tuple members. <strong>This means that if we store values types in the tuple, the types are copied/moved, and in conclusion, they have to by copyable/movable!</strong> This is the reason why we frequently use smart pointers in tuples even though we would reurn directly by value if we returned a single value.</p>
<h5 id="creating-tuples-with-stdmake_pair-or-stdmake_tuple">Creating tuples with <code>std::make_pair</code> or <code>std::make_tuple</code><a class="headerlink" href="#creating-tuples-with-stdmake_pair-or-stdmake_tuple" title="Permanent link">&para;</a></h5>
<p><strong>TLDR: from C++17, there is no reason to use <code>make_pair</code>/<code>make_tuple</code></strong>.</p>
<p>There are also factory methods <code>make_pair</code>/<code>make_tuple</code>. Before C++17, argument deduction did not work for constructors, so there is a dedicated  method for creating tuples. However, now we can just call the constructor and the template arguments are deduced from the constructor arguments. Also, the <code>make_pair</code>/<code>make_tuple</code> functions can only produce tuples containing values, not references (even if we specify the reference type in the <code>make_pair</code>/<code>make_tuple</code> template argument, the returned tuple will be value-typed). </p>
<h4 id="accessing-tuple-members">Accessing tuple members<a class="headerlink" href="#accessing-tuple-members" title="Permanent link">&para;</a></h4>
<p>The standard way to access the tuple/pair mamber is using the <a href="https://en.cppreference.com/w/cpp/utility/tuple/get"><code>std::get</code></a> function:</p>
<pre><code class="language-cpp">auto tuple = std::tuple&lt;int, std::string, float&gt;(0, &quot;hello&quot;, 1.5);
auto hello = std::get&lt;1&gt;(tuple);
</code></pre>
<h4 id="unpacking-tuples-into-variables">Unpacking tuples into variables<a class="headerlink" href="#unpacking-tuples-into-variables" title="Permanent link">&para;</a></h4>
<p>There are two scenarios of unpacking tuples into variables:</p>
<ul>
<li>unpacking into <strong>new variables</strong>: for that, we use <em>structured binding</em>.</li>
<li>unpacking into <strong>existing variables</strong>: for that, we use <code>std::tie</code> function.</li>
</ul>
<h5 id="structured-binding">Structured binding<a class="headerlink" href="#structured-binding" title="Permanent link">&para;</a></h5>
<p>If we don't need the whole tuple objects, but only its members, we can use a <a href="https://en.cppreference.com/w/cpp/language/structured_binding"><em>structured binding</em></a>. Example:</p>
<pre><code class="language-cpp">std::pair&lt;int, int&gt; get_data();

void main(){
    const auto&amp; [x, y] = get_data();
}
</code></pre>
<h5 id="stdtie"><code>std::tie</code><a class="headerlink" href="#stdtie" title="Permanent link">&para;</a></h5>
<p>If we want to unpack the tuple into existing variables, we can use the <a href="https://en.cppreference.com/w/cpp/utility/tuple/tie"><code>std::tie</code></a> function:</p>
<pre><code class="language-cpp">std::pair&lt;int, int&gt; get_data();

void main(){
    int x, y;
    std::tie(x, y) = get_data();
}
</code></pre>
<h4 id="unpacking-tuples-to-constructor-params-with-stdmake_from_tuple">Unpacking tuples to constructor params with <code>std::make_from_tuple</code><a class="headerlink" href="#unpacking-tuples-to-constructor-params-with-stdmake_from_tuple" title="Permanent link">&para;</a></h4>
<p>We cannot use structured binding to unpack tuple directly into function arguments. For normal functions, this is not a problem, as we can first use structured binding into local variables, and then we use those variables to call the function. However, it is a problem for parent/member initializer calls, as we cannot introduce any variables there. Luckily, there is a <a href="https://en.cppreference.com/w/cpp/utility/make_from_tuple"><code>std::make_from_tuple</code></a> template function prepared for this purpose. Example:</p>
<pre><code class="language-cpp">std::tuple&lt;int,float&gt; get_data(){
...
}

class Parent{
public:
    Parent(int a, float b){...}
{

class Child: public Parent{
public:
    Child(): Parent(std::make_from_tuple&lt;Parent&gt;(get_data())){}
}
</code></pre>
<h2 id="stdoptional"><code>std::optional</code><a class="headerlink" href="#stdoptional" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional">cppreference</a></p>
<p><code>std::optional&lt;T&gt;</code> is a class template that can be used to store a value of type <code>T</code> or nothing. The advantage over other options like null pointers or is that the <code>std::optional</code> is a value type, so it can wrap stack objects as well.</p>
<p>The <strong>type <code>T</code> must satisfy <code>std::is_move_constructible_v&lt;T&gt;</code></strong> (must be either movable or copyable).</p>
<p>The usage is easy as the class has a value constructor from <code>T</code> and a default constructor that creates an empty optional. Also, the type <code>T</code> is convertible to <code>std::optional&lt;T&gt;</code>, and <code>std::nullopt</code> is convertible to an empty optional. Finally, <code>std::optional&lt;T&gt;</code> is convertible to <code>bool</code>, so it can be used in <code>if</code> statements.</p>
<p>A typical usage is:</p>
<pre><code class="language-cpp">class My_class{
public:
    My_class(int a, int b);
}

std::optional&lt;My_class&gt; f(){
    ...
    return My_class(a, b);
    // or 
    return {a, b};

    // or, in case of fail
    return std::nullopt; 
}
std::optional&lt;int&gt; a = f();
if(a){
    // a has a value
}
</code></pre>
<h2 id="unions-and-variants">Unions and Variants<a class="headerlink" href="#unions-and-variants" title="Permanent link">&para;</a></h2>
<p>The idea of a union is to store multiple types in the same memory location. Compared to the polymorphism, when we work with pointers and to templates, where the actual type is determined at compile time, the union actually has a shared memory for all the types.</p>
<p>The union can be therefore used in cases where nor polymorphism neither templates are suitable. One example can be storing different unrelated types (e.g., <code>std::string</code> and <code>int</code>) in a container. We cannot use templates as that require a single type. Nor we can use polymorphism, as the types are unrelated. </p>
<p>The big disadvantage of unions is that they are not type safe. The compiler cannot check if the type we are accessing is the same as the type we stored. Therefore, we have to be very careful when using unions. Therefore, unless some special case, <strong>we should use <a href="https://en.cppreference.com/w/cpp/utility/variant"><code>std::variant</code></a> instead of unions</strong>.</p>
<h3 id="stdvariant"><code>std::variant</code><a class="headerlink" href="#stdvariant" title="Permanent link">&para;</a></h3>
<p>The declaration of <code>std::variant</code> is similar to the declaration of <code>std::tuple</code>:</p>
<pre><code class="language-cpp">std::variant&lt;int, double&gt; v;
</code></pre>
<p>The <code>std::variant</code> can store any of the types specified in the template parameters. The only requirement is that the types are default constructible. Also, incompatible types cannot be stored in <code>std::variant</code>, as we cannot use them as template arguments. However, we can use pointers or references to incompatible types instead.</p>
<p>The <strong>type</strong> of the stored value can be obtained using:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant/holds_alternative"><code>std::holds_alternative</code></a> method that returns a boolean value if the variant stores the type specified in the template parameter or</li>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant/index"><code>std::variant::index</code></a> method that returns the index of the stored value.<ul>
<li>this method can be used also in a <strong>switch statement</strong> as the index is integral</li>
</ul>
</li>
</ul>
<p>The <strong>value</strong> can be accessed using:</p>
<ul>
<li>the <a href="https://en.cppreference.com/w/cpp/utility/variant/get"><code>std::get</code></a> function, if we know the type stored in the variant or</li>
<li>the <a href="https://en.cppreference.com/w/cpp/utility/variant/get_if"><code>std::get_if</code></a> function if we are guesing the type.</li>
</ul>
<p>Both functions return a pointer to the stored value. Example:</p>
<pre><code class="language-cpp">std::variant&lt;int, double&gt; v = 1;
std::cout &lt;&lt; v.index() &lt;&lt; std::endl; // prints 0
std::cout &lt;&lt; *std::get_if&lt;int&gt;(&amp;v) &lt;&lt; std::endl; // prints 1
</code></pre>
<p>A really usefull feature of <code>std::variant</code> is the <code>std::visit</code> method, which allows us to call a function on the stored value. The function is selected based on the type of the stored value. Example:</p>
<pre><code class="language-cpp">std::variant&lt;int, double&gt; v = 1;
std::visit([](auto&amp;&amp; arg) { std::cout &lt;&lt; arg &lt;&lt; std::endl; }, v); // prints 1
</code></pre>
<p>More on variants:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant">cppreference</a></li>
<li><a href="https://www.cppstories.com/2018/06/variant/">cppstories</a></li>
</ul>
<h2 id="storing-individual-bits-in-a-sequence">Storing individual bits in a sequence<a class="headerlink" href="#storing-individual-bits-in-a-sequence" title="Permanent link">&para;</a></h2>
<p>Storing individual bits is a strategy for saving memory in high-performance applications, where each saved bit can have a dramatical impact on the performance. When working with small amounts of objects (less than millions), these strategies are not worth the effort, as we can store information in built-in types like <code>int</code>, <code>char</code>, or <code>bool</code>.</p>
<p>There are multiple strategies for storing individual bits where each bit has its own meaning:</p>
<ul>
<li>using built-in arithmetic types and accessing individual bits using bit masks</li>
<li><a href="https://en.cppreference.com/w/cpp/utility/bitset"><code>std::bitset</code></a></li>
<li>using <a href="https://en.cppreference.com/w/cpp/language/bit_field">bitfields</a></li>
<li>using <code>std::vector&lt;bool&gt;</code></li>
</ul>
<p>The best strategy depends on the use case. The following table summarizes the pros and cons of the different strategies:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>built-in arithmetic types</th>
<th><code>std::bitset</code></th>
<th>bitfields</th>
<th><code>std::vector&lt;bool&gt;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Maximum size per variable</td>
<td>64 bits</td>
<td>unlimited</td>
<td>64 bits</td>
<td>unlimited</td>
</tr>
<tr>
<td>Dynamic size</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody>
</table>
<h3 id="reading-a-subsequnece-of-bits">Reading a subsequnece of bits<a class="headerlink" href="#reading-a-subsequnece-of-bits" title="Permanent link">&para;</a></h3>
<p>For reading individual bits or the whole sequence of bits, each strategy has its own way of doing it. However, for reading a subsequence of bits, there is no machinery, so we have to resort to bit operations no matter of the strategy.</p>
<p>For skipping first <code>n</code> bits, we use the right shift (<code>&gt;&gt;</code>) or the left shift operator, depending on endians. For skipping last <code>n</code> bits, we use a bitmask and the and (<code>&amp;</code>) operator.</p>
<p>Example:</p>
<pre><code class="language-cpp">std::bitset&lt;8&gt; b = 0b10101010;
std::cout &lt;&lt; b.to_ulong() &lt;&lt; std::endl; // prints 170


</code></pre>
<h3 id="stdbitset"><code>std::bitset</code><a class="headerlink" href="#stdbitset" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/utility/bitset">cppreference</a></p>
<p><code>std::bitset&lt;N&gt;</code> is a class template that can store up to <code>N</code> bits.</p>
<h4 id="reading">Reading<a class="headerlink" href="#reading" title="Permanent link">&para;</a></h4>
<p>To <strong>read a single bit</strong>, we can use:</p>
<ul>
<li>the <a href="https://en.cppreference.com/w/cpp/utility/bitset/test"><code>test</code></a> member function that returns a boolean value</li>
<li>the <a href="https://en.cppreference.com/w/cpp/utility/bitset/operator_at"><code>operator[]</code></a> operator that returns a boolean value</li>
</ul>
<p>To <strong>read more bits at once</strong>, we can use:</p>
<ul>
<li>the <a href="https://en.cppreference.com/w/cpp/utility/bitset/to_ulong"><code>to_ulong</code></a> member function that returns an <code>unsigned long</code> value</li>
<li>the <a href="https://en.cppreference.com/w/cpp/utility/bitset/to_ullong"><code>to_ullong</code></a> member function that returns an <code>unsigned long long</code> value</li>
</ul>
<p>Both methods convert the whole bitset to an integer value of the corresponding type. If the bitset is larger than the integer type, an exception is thrown.</p>
<p><strong>There is no function for reading a specified sequence of bits</strong>. One way to overcome this is to read the whole bitset and apply a series of bit operations to get the desired bits (same as we would do with built-in arithmetic types). Another, slower option is to read the bits one by one using for loop.</p>
<h1 id="value-categories">Value Categories<a class="headerlink" href="#value-categories" title="Permanent link">&para;</a></h1>
<p>[cppreferencepreerecege/value_category).
In many contexts, the value category of an expression is important in deciding whether the code compiles or not, or which function or template overload is chosen. Therefore, it is usefull to be able to read value categories.</p>
<p>expression value types:</p>
<ul>
<li><em>lvalue</em>, meaning left-value. An expression typically on the left side of compound expression a statement, e.g. variable, member, or function name. Also, lvalues expressions are are:<ul>
<li>function ratoalls to fuctions returning lvalue</li>
<li>assignments</li>
<li><code>++a</code>, <code>--a</code> and similar pre operators</li>
<li><code>*a</code> indirection</li>
<li>string literal</li>
<li>cast</li>
</ul>
</li>
<li><em>prvalue</em>, meaning pure rvalue. It is either a result of some operand (<code>+</code>, <code>/</code>) or a constructor/initializer result. The foloowing expressions are prvalues:<ul>
<li>literals with exception of string literals, e.g.: <code>4</code>, <code>true</code>, <code>nullptr</code></li>
<li>function or operator calls that return rvalue (non-reference)</li>
<li><code>a++</code>, <code>a--</code> and other post operators</li>
<li>arithmetic and logical expressions</li>
<li><code>&amp;a</code> address of expression</li>
<li><code>this</code></li>
<li>non-type template parameters, unless they are references</li>
<li>lambda expressions</li>
<li>requires expressions and concept spetializations</li>
</ul>
</li>
<li><em>xvalue</em>, meaning expiring value. These valaues usually represent lvalues converted to rvalues. Xvalue expressions are:<ul>
<li>function call to functions returning rvalue reference (e.g., <a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a>).</li>
<li>member object expression (<code>a.m</code>) if <code>a</code> is an rvlaue and <code>m</code> is a non-reference type</li>
</ul>
</li>
<li><em>glvalue</em> = <em>lvalue</em> <code>||</code> <em>xvalue</em>. </li>
<li><em>rvalue</em> = <em>prvlaue</em> <code>||</code> <em>xvalue</em>. </li>
</ul>
<h1 id="operators">Operators<a class="headerlink" href="#operators" title="Permanent link">&para;</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/operators">cppreferencen</a></p>
<p>C++ supports almost all the standard operators known from other languages like Java, Python, or C#. Additionally, thsese operators can be overloaded.</p>
<p>There are several categories of operators:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic">arithmetic operators</a>, including bitwise operators</li>
<li><a href="https://en.cppreference.com/w/cpp/language/operator_comparison">comparison operators</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/operator_logical">logical operators</a></li>
<li>assignment operators</li>
</ul>
<p>Note that the standard also supports <a href="https://en.cppreference.com/w/cpp/language/operator_alternative"><strong>alternative tokens</strong></a> for some operators (e.g., <code>&amp;&amp;</code> -&gt; <code>and</code>, <code>||</code> -&gt; <code>or</code>, <code>!</code> -&gt; <code>not</code>). However, these are not supported by all compilers. In MSVC, the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=vs-2019"><code>/permissive-</code></a> flag needs to be used to enable these tokens.</p>
<h2 id="user-defined-operators">User-defined Operators<a class="headerlink" href="#user-defined-operators" title="Permanent link">&para;</a></h2>
<p>In C++ there are more operators than in other popular es like Python or Java. Additionally, these operators can be overloaded. See <a href="https://en.cppreferencempp.com/w/cpp/language/operators">cppreferencen</a> page for detailed description.</p>
<h2 id="comparison-operators">Comparison Operators<a class="headerlink" href="#comparison-operators" title="Permanent link">&para;</a></h2>
<h3 id="default-comparison-operators">Default Comparison Operators<a class="headerlink" href="#default-comparison-operators" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/default_comparisons">cppreference</a>.</p>
<p>The <code>!=</code> is usually not a problem, because it is implicitely generated as a negation of the <code>==</code> operator. However, <strong>the <code>==</code> is not generated by default, even for simple classes</strong>. To force the generation of a default member-wise comparison operator, we need to write:</p>
<pre><code class="language-c++">bool operator==(const My_class&amp;) const = default;
</code></pre>
<p>However, to do that, all members and base classes have to ae the operator <code>==</code> defined, otherwise the default operator will be implicitely deleted.</p>
<p>The comparability can be checked with a <code>std::equality_comparable&lt;T&gt;</code> concept:</p>
<pre><code class="language-cpp">staic_assert(std::equality_comparable&lt;My_class&gt;);
</code></pre>
<h1 id="control-structures">Control Structures<a class="headerlink" href="#control-structures" title="Permanent link">&para;</a></h1>
<p>C++ supports the control structures known from other languages like Java, Python, or C#. Here, we focus on the specifics of C++.</p>
<h2 id="switch-statement">Switch Statement<a class="headerlink" href="#switch-statement" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/switch">cppreference</a></p>
<p>In C++, we can switch on integer types or enumeration types. Also, we can use classes that are implicitely convertible to integers or enums. Switch on string is not possible.</p>
<p>The switch statement has the following syntax:</p>
<pre><code class="language-cpp">switch(expression){
    case value1:
        // code
        break;
    case value2:
        // code
        break;
    default:
        // code
}
</code></pre>
<p>However, it is usually a good idea to wrap each case in a block to create a separate scope for each case. Without it, the whole switch is a single block (contrary to if/else statements). The swich statements just jump to a case that matches the value, similarly to a <code>goto</code> statement. This can create problems, as for example variable initialization cannot be jumped over. The safe case statement looks like:</p>
<pre><code class="language-cpp">switch(expression){
    case value1:{
        // code
        break;
    }
    case value2:{
        // code
        break;
    }
    default:{
        // code
    }
}
</code></pre>
<h1 id="functions">Functions<a class="headerlink" href="#functions" title="Permanent link">&para;</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/functions">cppreference</a></p>
<h2 id="function-declaration-and-definition">Function Declaration and Definition<a class="headerlink" href="#function-declaration-and-definition" title="Permanent link">&para;</a></h2>
<p>In C and C++, functions must have a:
- <strong>declaration</strong> (signature) that specifies the function name, return type, and parameters
- <strong>definition</strong> that specifies the function body</p>
<p>The declaration has to be provided before the first use (call) of the function. The definition can be provided later.</p>
<p>The declaration is typically provided in a header file, so that the function can be used outside the translation unit. The definition is typically provided in a source file.</p>
<h3 id="merged-declaration-and-definition">Merged Declaration and Definition<a class="headerlink" href="#merged-declaration-and-definition" title="Permanent link">&para;</a></h3>
<p>If the function is not used outside the translation unit, the declaration and definition can be merged, i.e., the definition is itself a declaration. However, this is not recommended because after adding a corresponding declaration to one of the included headers (including libraries), the merged declaration/definition will become a definition of that function, which will be manifested as a linker error (multiple definitions of the function). Therefore, to control the visibility of the function, it is better to use other methods, provides in Section <a href="#function-visibility">Visibility of Functions</a>.</p>
<h2 id="deciding-between-free-function-member-function-and-static-member-function">Deciding between free function, member function and static member function<a class="headerlink" href="#deciding-between-free-function-member-function-and-static-member-function" title="Permanent link">&para;</a></h2>
<p>Basically, you should decide as follows:</p>
<ol>
<li>Function needs access to instance -&gt; <strong>member function</strong></li>
<li>Function <ul>
<li>should be called only by class members (i.e., member functions), so we want to limit its visibility, or</li>
<li>we need to access static members of the class -&gt; <strong>static member function</strong></li>
</ul>
</li>
<li>Otherwise -&gt; <strong>free function</strong></li>
</ol>
<h2 id="argument-parameter-conversions">Argument-parameter Conversions<a class="headerlink" href="#argument-parameter-conversions" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Arg/param</th>
<th>value</th>
<th>reference</th>
<th>rvalue</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>-</td>
<td>-</td>
<td><code>std::move</code></td>
</tr>
<tr>
<td>reference</td>
<td>implicit copy</td>
<td>-</td>
<td>copy constructor</td>
</tr>
<tr>
<td>rvalue</td>
<td>-</td>
<td>not possible</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="default-parameters">Default Parameters<a class="headerlink" href="#default-parameters" title="Permanent link">&para;</a></h2>
<p>Default function parameters  in C++ works similarly to other languages:</p>
<pre><code class="language-c++">int add(int a, int b = 10);

add(1, 2) // 3
add(1) // 11
</code></pre>
<p>However, the default parameters works only if we call the function by name. Therefore, we cannot use them in std::function and similar contexts. Example:</p>
<pre><code class="language-c++">std::function&lt;int(int,int)&gt; addf = add;
std::function&lt;int(int)&gt; addf = add; // does not compile

addf(1) // does not compile
</code></pre>
<p>Also, the default parameters need to be values, not references or pointers. For references and pointers, we should use function overloading.</p>
<h3 id="default-parameters-and-inheritance">Default Parameters and Inheritance<a class="headerlink" href="#default-parameters-and-inheritance" title="Permanent link">&para;</a></h3>
<p>TLDR: do not use default parameters in virtual functions.</p>
<p>The default parameters are resolved at compile time. Therefore, the value does not depend on the actual type of the object, but on the declared type of the variable. This have following consequences:</p>
<ul>
<li>the default parameters are not inherited</li>
<li><code>A* a = new B(); a-&gt;foo()</code> will call <code>B::foo()</code>, with the default parameters of <code>A::foo()</code></li>
</ul>
<p>To prevent confusion with inheritence we should use function overloading instead of default parameters in virtual functions (like in Java).</p>
<h2 id="return-values-and-nrvo">Return values and NRVO<a class="headerlink" href="#return-values-and-nrvo" title="Permanent link">&para;</a></h2>
<p>For deciding the return value format, refer to the <a href="https://drive.google.com/file/d/1Ml6g63_mbgjmRRByIItayAuEnhDymnH_/view?usp=sharing">return value decision tree</a>.</p>
<p>Especially, note that <a href="https://en.wikipedia.org/wiki/Copy_elision#RVO">NRVO</a> is used in modern C++ and therefore, we can return all objects by value with no overhead most of the time.</p>
<p>The NRVO works as follows:</p>
<ol>
<li>compiler tries to just tranfer the object to the parent stack frame (i. e. to the caller) without any move or copy</li>
<li>if the above is not possible, the move constructor is called.</li>
<li>if the above is not possible, the copy constructor is called.</li>
</ol>
<p>From C++17, the RVO is mandatory, therefore, it is unlikely that the compiler use a move/copy constructor.
Consequently, most of the times, we can just return the local variable and let the rest to the compiler:</p>
<pre><code class="language-cpp">unique_ptr&lt;int&gt; f(){
  auto p = std::make_unique&lt;int&gt;(0);

  return p; // works, calls the move constructor automatically in the worst case (pre C++17 compiler)
  // return move( p ); // also works, but prevents NRVO
}
</code></pre>
<p>The NRVO is described also on <a href="https://en.cppreference.com/w/cpp/language/copy_elision">cppreference</a> together with initializer copy elision.</p>
<h2 id="function-overlaoding">Function Overlaoding<a class="headerlink" href="#function-overlaoding" title="Permanent link">&para;</a></h2>
<p>Both normal and member funcions in C++ can be overloaded. The oveload mechanic, however, is quite complicated. There can be three results of overload resolution of some function call:</p>
<ul>
<li>no function fits -&gt; error</li>
<li>one function fits the best</li>
<li>multiple functions fits the best -&gt; error</li>
</ul>
<p>The whole algorithm of overload resolution can be found on <a href="https://en.cppreference.com/w/cpp/language/overload_resolution">cppreference</a>.</p>
<p>First, <em>viable</em> funcions are determined as functions with the same name and:</p>
<ul>
<li>with the same number of parameters</li>
<li>with a greater number of parameters if the extra parameters has default arguments</li>
</ul>
<p>If there are no viable functions, the compilation fails. Otherwise, all viable functions are compared to get the best fit. The comparison has multiple levels. The basic principle is that if only one function fits the rules at certain level, it is chosen as a best fit. If there are multiple such functions, the compilation fails. Levels:</p>
<ol>
<li>
<p>Better <em>conversion</em> priority (most of the time, the best fit is found here, see conversion priority and ranking bellow)</p>
</li>
<li>
<p>non-template constructor priority</p>
</li>
</ol>
<h3 id="conversion-prioritiy-and-ranking">Conversion prioritiy and ranking<a class="headerlink" href="#conversion-prioritiy-and-ranking" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/overload_resolution#Ranking_of_implicit_conversion_sequences">cppreference</a></p>
<p>When the conversion takes priority during the best viable function search, we say it is <em>better</em>. The (incomplete) algorithm of determining <em>better</em> conversion works as follows:</p>
<ol>
<li>standard conversion is better than user defined conversion</li>
<li>user defined conversion is better then elipsis (<code>...</code>) conversion</li>
<li>comparing two standard conversions:<ol>
<li>if a conversion sequence S1 is a subsequence of conversion sequence S2, S1 is better then S2</li>
<li>lower rank priority</li>
<li>rvalue over lvalue if both applicable</li>
<li>ref over const ref if both applicable</li>
</ol>
</li>
</ol>
<h4 id="conversion-sequence-ranks">Conversion sequence ranks<a class="headerlink" href="#conversion-sequence-ranks" title="Permanent link">&para;</a></h4>
<ol>
<li><strong>exact match</strong></li>
<li><strong>promotion</strong></li>
<li><strong>conversion</strong>: includes class to base conversion</li>
</ol>
<h3 id="constructor-argument-type-resolution-in-list-initialization">Constructor argument type resolution in list initialization<a class="headerlink" href="#constructor-argument-type-resolution-in-list-initialization" title="Permanent link">&para;</a></h3>
<p>When we use a list initailization <strong>and</strong> it results in a constructor call, it is not immediatelly clear which types will be used for arguments as the initialization list is not an expression. These types are, however, critical for the finding of best viable constructor. The following rules are used to determine the argument types (simplified):</p>
<ol>
<li></li>
</ol>
<h2 id="auto-return-type"><code>auto</code> return type<a class="headerlink" href="#auto-return-type" title="Permanent link">&para;</a></h2>
<p>For functions that are defined inside declaration (template functions, lambdas), the return type can be automatically deduced if we use the <code>auto</code> keyword. </p>
<p>The decision between value and reference return type is made according to the following rules:</p>
<ul>
<li>return type <code>auto</code> -&gt; return by value</li>
<li>return type <code>auto&amp;</code> -&gt; return by reference</li>
<li>return type <code>auto*</code> -&gt; return by pointer</li>
<li>return type <code>decltyype(auto)</code> -&gt; the return type is <code>decltype(&lt;RETURN EXPRESSION&gt;)</code></li>
</ul>
<p>See more rules on <a href="https://en.cppreference.com/w/cpp/language/function#Return_type_deduction">cppreference</a></p>
<p>Note that <strong>the <code>auto</code> return type is not allowed for functions defined outside the declaration</strong> (unless using the trailing return type).</p>
<h2 id="function-visibility">Function visibility<a class="headerlink" href="#function-visibility" title="Permanent link">&para;</a></h2>
<p>The <strong>member function</strong> visibility is determined by the access specifier, in the same manner as the member variable visibility. </p>
<p>For <strong>free functions</strong>, the visibility is determined by the <em>linkage specifier</em>. Without the specifier, the function is visible. To make it visible only in the current translation unit, we can use the <code>static</code> specifier. </p>
<p>An equivalent way to make a function visible only in the current translation unit is to put it into an <em>anonymous namespace</em>:</p>
<pre><code class="language-cpp">namespace {
    void f() {}
}
</code></pre>
<p>This way, the function is visible in the current translation unit, as the namespace is implicitly imported into it, but it is not visible in other translation units, because anonymous namespaces cannot be imported.</p>
<p>One of the other approches frequently used in C++ is to <strong>put the function declaration into the source file</strong> so it cannot be included from the header. This solution is, however, flawed, unsafe, and therefore, <strong>not recommended</strong>. The problem is that this way, the function is still visible to the linker, and can be mistakenly used from another translation unit if somebody declare a function with the same name.</p>
<h2 id="deleting-functions">Deleting functions<a class="headerlink" href="#deleting-functions" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/function#Deleted_functions">cppreference</a></p>
<p>We can delete functions using the <code>delete</code> keyword. This is mostly used for preventing the usage of copy/move constructors and assignment operators. However, it can be used for any function, as we illustrate in the following example:</p>
<pre><code class="language-cpp">class My_class{
    print_integer(int a){
        std::cout &lt;&lt; a &lt;&lt; std::endl;
    }
    // we do not want to print doubles even they can be implicitly converted to int
    print_integer(double a) = delete; 
}
</code></pre>
<h1 id="classes-and-structs">Classes and structs<a class="headerlink" href="#classes-and-structs" title="Permanent link">&para;</a></h1>
<p>The only difference between a <code>class</code> and a <code>struct</code> is that in class, all 
members are private by default.</p>
<h2 id="class-constants">Class Constants<a class="headerlink" href="#class-constants" title="Permanent link">&para;</a></h2>
<p>Class constants can be defined in two ways:</p>
<ul>
<li><code>static constexpr</code> member variable if the constant type supports <code>constexpr</code> specifier, or</li>
<li><code>static const</code> member variable </li>
</ul>
<p>In the second case, we have to split the declaration and definition of the variable to avoid multiple definitions:</p>
<pre><code class="language-cpp">// in the header file
class My_class{
    static const int a;
}

// in the cpp file
const int My_class::a = 5;
</code></pre>
<h2 id="friend-declaration">Friend declaration<a class="headerlink" href="#friend-declaration" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreferececom/friend">cppreference</a></p>
<p>Sometimes, we need to provide an access to privat e members of a class to some other classes. In java, for example, we can put both classes to the same package and set the members as package private (no specifier). In C++, there is an even stronger concept of friend classes.</p>
<p>We put a <code>friend</code> declaration to the body of a class whose <em>private</em> members should be accessible from some other class. The declaratiton can look as follows:</p>
<pre><code class="language-cpp">Class To_be_accesssed {
    friend Has_access;
}
</code></pre>
<p>Now the <code>Has_access</code> class has access to the <code>To_be_accesssed</code>'s private members.</p>
<p>Note that the <strong>friend relation is not transitive, nor symetric, and it is not inherited.</strong></p>
<h3 id="template-friends">Template friends<a class="headerlink" href="#template-friends" title="Permanent link">&para;</a></h3>
<p>If we want a template to be a friend, we can modify the code above:</p>
<pre><code class="language-cpp">class To_be_accesssed {
    template&lt;class T&gt;
    friend class Has_access;
}
</code></pre>
<p>Now every <code>Has_access&lt;T&gt;</code> is a friend of <code>To_be_accesssed</code>. Note thet we need to use keyword <code>class</code> next to <code>friend</code>.</p>
<p>We can also use only a template spetialization: </p>
<pre><code class="language-cpp">class To_be_accesssed {
    friend class Has_access&lt;int&gt;;
}
</code></pre>
<p>or we can bound the allowed types of two templates togehter if both <code>Has_access</code> and of <code>To_be_accesssed</code> are templates:</p>
<pre><code class="language-cpp">template&lt;class T&gt;
class To_be_accesssed {
    friend class Has_access&lt;T&gt;;
}
</code></pre>
<h1 id="initialization-and-assignment">Initialization and Assignment<a class="headerlink" href="#initialization-and-assignment" title="Permanent link">&para;</a></h1>
<h2 id="loacal-variables-initializationassignment">Loacal variables initialization/assignment<a class="headerlink" href="#loacal-variables-initializationassignment" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/initialization">Initialization</a> happens in many <strong>contexts</strong>:</p>
<ul>
<li>in the declaration</li>
<li>in <code>new</code> expression</li>
<li>function parameter initialization</li>
<li>return value initialization</li>
</ul>
<p>The <strong>syntax</strong> can be:</p>
<ul>
<li><code>(&lt;expression list&gt;)</code></li>
<li><code>= expression list</code></li>
<li><code>{&lt;initializer list&gt;}</code></li>
</ul>
<p>Finally, there are multiple initialization types, the resulting <strong>initialization type</strong> depends on both context and syntax:</p>
<ul>
<li>Value initialization: <code>std::string s{};</code></li>
<li>Direct initialization: <code>std::string s{"value"}</code></li>
<li>Copy initialization: <code>std::string s = "value"</code></li>
<li>List initialization: <code>std::string s{'v', 'a', 'l', 'u', 'e'}</code></li>
<li>Aggregate initialization: <code>char a[3] = {'a', 'b'}</code></li>
<li>Reference initialization: <code>char&amp; c = a[0]</code></li>
<li>Default initialization: <code>std::string s</code></li>
</ul>
<h3 id="list-initialization">List initialization<a class="headerlink" href="#list-initialization" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/list_initialization">List initialization</a> initializes an object from a list. he list initialization has many forms, including:</p>
<ul>
<li><code>My_class c{arg_1, arg_2}</code> </li>
<li><code>My_class c = {arg_1, arg_2}</code></li>
<li><code>my_func({arg_1, arg_2})</code></li>
<li><code>return {arg_1, arg_2}</code></li>
</ul>
<p>The list initialization of a type <code>T</code> can result in various initializations/constructios depending on many aspects. Here is the simplified algorithm:
 1. <code>T</code> is aggregate -&gt; aggregate initialization
 2. The initializer list is empty and <code>T</code> has a default constructor -&gt; value initialization
 3. <code>T</code> has an constructor accepting <code>std::initializer_list</code> -&gt; this constructor is called
 4. other constructors of <code>T</code> are considered, excluding explicit constructors</p>
<h3 id="value-initialization">Value initialization<a class="headerlink" href="#value-initialization" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/value_initialization">cppreference</a></p>
<p>This initializon is performed when we do not porvide any parameters for the initialization. Depending on the object, it results in either defualt or zero initialization.</p>
<h3 id="aggregate-initialization">Aggregate initialization<a class="headerlink" href="#aggregate-initialization" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate initialization</a> is an initialization for aggregate types. It is a form of list initialization. Example:</p>
<pre><code class="language-cpp">My_class o1{arg_1, arg_2};
My_class o2 = {arg_1, arg_2}; // equivalent
</code></pre>
<p>The list initialization of type <code>T</code> from an initializer list results in aggregate initialization if these conditions are fullfilled:</p>
<ul>
<li>the initializer list contains more then one element</li>
<li>T is an aggregate type</li>
</ul>
<h3 id="nested-initialization">Nested initialization<a class="headerlink" href="#nested-initialization" title="Permanent link">&para;</a></h3>
<p><strong>It is not possible to create nested initializatio statements</strong> like:</p>
<pre><code class="language-cpp">class My_class{
    int a,
    float b;

public:
    My_class(ina a, float b): a(a), b(b)
}

std::tuple&lt;int, My_class&gt;{2, {3, 2.5}} // does not compile
std::tuple&lt;int, My_class&gt;{2, My_class{3, 2.5}} // correnct version
</code></pre>
<h2 id="member-initializationassignment">Member Initialization/Assignment<a class="headerlink" href="#member-initializationassignment" title="Permanent link">&para;</a></h2>
<p>There are two ways of member initialization:</p>
<ul>
<li><strong>default member initialization</strong></li>
<li>initialization using <strong>member initializer list</strong></li>
</ul>
<p>And then, there is an assignment option in  <strong>constructor body</strong> .</p>
<p>Reference:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/data_members#Member_initialization">default member initialization</a></li>
<li><a href="https://en.cppreference.comwcplng/w/cpp/language/constructor">constructor and initializer list</a></li>
</ul>
<p>One way or another, <strong>all members should be initialized at the constructor body at latest</strong>, even if we assign them again during all possible use cases. Reason:</p>
<ul>
<li>some types (numbers, enums, ...) can have arbitrary values when unassigned. This can lead to confusion when debugging the class, i.e., the member can appear as initialized even if it is not.</li>
<li>easy support for overloading constructors, we can sometimes skip the call to the constructor with all arguments</li>
<li>we can avoid default arguments in the constructor</li>
</ul>
<p>It is important to <strong>not use virtual functions in member initialization or constructor body</strong>, because the function table is not ready yet, so the calls are hard wired, and the results can be unpredictable, possibly compiler dependent.</p>
<h3 id="default-member-initialization">Default Member Initialization<a class="headerlink" href="#default-member-initialization" title="Permanent link">&para;</a></h3>
<p>Either a <strong>brace initializer</strong>:</p>
<pre><code class="language-C++">My_class{
    int member{1} 
}
</code></pre>
<p>or an <strong>equals initializer</strong>:</p>
<pre><code class="language-C++">My_class{
    int member = 1 
}
</code></pre>
<h3 id="member-initializer-list">Member Initializer List<a class="headerlink" href="#member-initializer-list" title="Permanent link">&para;</a></h3>
<p>Either using <a href="https://en.cppreference.com/w/cpp/language/direct_initialization"><strong>direct initialization</strong></a> (calling constructor of <code>member</code>):</p>
<pre><code class="language-C++">My_class{
    My_class(): member(1){
    }
</code></pre>
<p>or <a href="https://en.cppreference.com/w/cpp/language/list_initialization"><strong>list initialization</strong></a>:</p>
<pre><code class="language-C++">My_class{
    My_class(): member{1}{
    }
</code></pre>
<h3 id="constructor-body">Constructor Body<a class="headerlink" href="#constructor-body" title="Permanent link">&para;</a></h3>
<pre><code class="language-C++">My_class{
    My_class(){
        member = 1
    }
}
</code></pre>
<h3 id="comparison-table">Comparison Table<a class="headerlink" href="#comparison-table" title="Permanent link">&para;</a></h3>
<p>Ordered by priority, i.e., each method makes the methods bellow ignored/ovewritten if applied to the same member.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>In-place</th>
<th>works for const members</th>
</tr>
</thead>
<tbody>
<tr>
<td>Constructor body</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Member initializer list</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Default member initializer</td>
<td>yes, if we use direct initialization</td>
<td>yes</td>
</tr>
</tbody>
</table>
<h1 id="constructors-and-special-member-functions">Constructors and Special Member Functions<a class="headerlink" href="#constructors-and-special-member-functions" title="Permanent link">&para;</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/member_functions#Special_member_functions">cppreference</a></p>
<p>Special member functions are member functions that are someetimes defined implicitely by the compiler. The special member functions are:</p>
<ul>
<li>default (no parameter) constructor</li>
<li>copy constructor</li>
<li>copy assignment</li>
<li>move constructor</li>
<li>move assignment</li>
<li>destructor</li>
</ul>
<p>These functions can be:</p>
<ul>
<li>defined implicitely by the compiler</li>
<li>deleted implicitely by the compiler</li>
<li><em>defaulted</em>, i.e., defined by the compiler on our request
    <code>cpp
    My_class() = default;</code><ul>
<li>Along with the comparison operators, these are the only functions that can be  (see below).</li>
</ul>
</li>
<li><em>deleted</em>, i.e., disabled by the compiler on our request
    <code>cpp
    My_class(const My_class&amp;) = delete;</code></li>
</ul>
<p>By default, all special member functions are defined implicitely if the members satisfy the requirements (see below). However, if we define any of the special member functions, the implicit definition is disabled. Therefore, <strong>typically, we define all special member functions or none of them.</strong></p>
<h2 id="constructor">Constructor<a class="headerlink" href="#constructor" title="Permanent link">&para;</a></h2>
<h3 id="defualt-variant">Defualt Variant<a class="headerlink" href="#defualt-variant" title="Permanent link">&para;</a></h3>
<p>The default constructor just create an empty object. The default constructor is not implicitly generated if:</p>
<ul>
<li>there is anothe constructor declared, including copy and move constructor</li>
<li>there is some member that cannot be defaulty initialized</li>
</ul>
<h3 id="explicit-constructor">Explicit constructor<a class="headerlink" href="#explicit-constructor" title="Permanent link">&para;</a></h3>
<p>Sometimes, a normal constructor can lead to unexpected results, especially if it has only a single argument:</p>
<pre><code class="language-cpp">class My_string {
public:
    String(std::string string); // convert from std::string
    String(int length);   // construct empty string with a preallocated size
};

String s = 10;   // surprise: empty string of size 10 istead of &quot;10&quot;
</code></pre>
<p>To prevent these surprising conversion, we can mark the constructor <code>explicit</code>. The <code>explicit</code> keyword before the constructor name prevents the assigment using this constructor. The explicit constructor has to be explicitelly called.    </p>
<h3 id="call-one-constructor-from-another">Call one constructor from another<a class="headerlink" href="#call-one-constructor-from-another" title="Permanent link">&para;</a></h3>
<p>We can call one constructor from another using the <em><a href="https://en.cppreference.com/w/cpp/language/constructor#Delegating_constructor">delegating constructor</a></em>. The syntax is:</p>
<pre><code class="language-cpp">class My_class{
public:
    My_class(int a, int b): a(a), b(b){}
    My_class(int a): My_class(a, 0){} // delegating constructor
}
</code></pre>
<p>This way, we can call another constructor of the same class, or of the base class. </p>
<h2 id="copy-constructor">Copy Constructor<a class="headerlink" href="#copy-constructor" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/copy_constructor">cppreference</a></p>
<p>A copy constructor is called if an object is initialized from another object unless the move constructor is called as a better fit or the call is optimized out by <a href="https://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a>. Some examples:</p>
<ul>
<li>initializing a new object from an existing object:</li>
</ul>
<pre><code class="language-cpp">My_class a;

My_class b = a;  // copy constructor called
My_class c(a);  // copy constructor called
</code></pre>
<ul>
<li>passing an object to a function by value:</li>
</ul>
<pre><code class="language-cpp">void f(My_class a){...}

My_class a;
f(a); // copy constructor called
</code></pre>
<ul>
<li>returning an object by value where the type is not movable and the compiler cannot optimize the call out.</li>
<li>we call the copy constructor directly</li>
</ul>
<h3 id="implicit-declaration-and-implicit-deletion">Implicit declaration and implicit deletion<a class="headerlink" href="#implicit-declaration-and-implicit-deletion" title="Permanent link">&para;</a></h3>
<p>The copy constructor for type <code>T</code> is implicitely-declared if <code>T</code> has no declared user-defined copy constructors. </p>
<p>If some there are some user-defined copy constructors, we can still force the implicit declaration of the copy constructor using the <code>default</code> keyword</p>
<p>However, the implicit declaration does not mean that the copy constructor can be used! This is because the <strong>copy constructor can be implicitely defined as deleted</strong>. This happens if any of the following conditions is true:</p>
<ol>
<li>T has a non-static data member that cannot be copied. This can happen if any of the following is true:<ul>
<li>it has a deleted copy constructor,</li>
<li>the copy constructor is inaccessible (<strong>protected, private</strong>)</li>
<li>the copy constructor is ambiguous (e.g., multiple inheritance)</li>
</ul>
</li>
<li>T has a base class that cannot be copied, i.e., 1, 2, or 3 applies to at least one base class</li>
<li>T has a non-static data member or base class with inaccessible destructor</li>
<li>T has a rvlaue data member</li>
<li>T has a user-defined move constructor or move assignment operator (this rule does not apply for defaulted copy constructor)</li>
</ol>
<p>The default implementationof copy constructor calls recursively the copy constructor of all base classes and on all members. For a pointer member, the copy object’s member points to the same object as the original object’s member</p>
<h3 id="checking-if-a-class-is-copy-constructible">Checking if a class is copy constructible<a class="headerlink" href="#checking-if-a-class-is-copy-constructible" title="Permanent link">&para;</a></h3>
<p>We can check if a class is copy constructible using the <a href="https://en.cppreference.com/w/cpp/types/is_copy_constructible"><code>std::is_copy_constructible</code></a> type trait. </p>
<h2 id="copy-assignment">Copy Assignment<a class="headerlink" href="#copy-assignment" title="Permanent link">&para;</a></h2>
<p>Copy Assignment is needed when  we use the <code>=</code> operator with the existing class instances, e.g.:</p>
<pre><code class="language-cpp">Class instanceA {};
Class instanceB;
instanceB = instance A
</code></pre>
<h2 id="move-constructor">Move Constructor<a class="headerlink" href="#move-constructor" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/move_constructor">cppreference</a></p>
<p>Move constructor semantic is that the new object takes the ownership of the resources of the old object. The state of the old object is unspecified, but it should not be used anymore. </p>
<p>Move constructor is typically called when the object is initaialized from xvalue (but not prvalue!) of the same type. Examples:</p>
<ul>
<li>returning xvalue: </li>
</ul>
<pre><code class="language-cpp">Type f(){
    Type t;
    return std::move(t);
}
</code></pre>
<ul>
<li>passing argument as xvalue:</li>
</ul>
<pre><code class="language-cpp">f(Type t){
    ...
}
Type t
f(std::move(t)); 
</code></pre>
<ul>
<li>initializing from xvalue:</li>
</ul>
<pre><code class="language-cpp">Type t;
Type t2 = std::move(t);
</code></pre>
<p>Note that for prvalues, the move call is eliminated by <a href="https://en.cppreference.com/w/cpp/language/copy_elision">copy elision</a>. Therefore, some calls that suggest move constructor call are actually optimized out:</p>
<pre><code class="language-cpp">Type f(){
    Type t;
    return t; // no move constructor call, copy elision
}

Type t = T(f()) // no move constructor call, copy elision
</code></pre>
<p>Move constructor is needed:</p>
<ul>
<li>to cheaply move the object out from function if RVO is not possible</li>
<li>to store the object in vector without copying it</li>
</ul>
<p>Note that a single class can have multiple move constructors, e.g.: both <code>Type(Type&amp;&amp;)</code> and <code>Type(const Type&amp;&amp;)</code>.</p>
<h3 id="implicit-declaration-and-implicit-deletion_1">Implicit declaration and implicit deletion<a class="headerlink" href="#implicit-declaration-and-implicit-deletion_1" title="Permanent link">&para;</a></h3>
<p>The move constructor for type <code>T</code> is implicitely-declared if <code>T</code> has no declared copy constructors, copy assignment operators, move assignment operators, or destructors.</p>
<p>If some of the above is declared, we can still force the implicit declaration of the move constructor using the <code>default</code> keyword</p>
<p>However, that does not mean that the move constructor can be used! This is because the <strong>move constructor can be implicitely defined as deleted</strong>. This happens if any of the following conditions is true:</p>
<ol>
<li>T has a non-static data member that cannot be moved. A member cannot be moved if any of the following is true:<ul>
<li>it has a deleted, inaccessible (protected, private), or ambiguous move constructor,</li>
<li>it is a reference,</li>
<li>it is <strong>const</strong>-qualified</li>
</ul>
</li>
<li>T has a base class that cannot be moved, i.e., 1, 2, or 3 applies to at least one base class</li>
<li>T has a non-static data member or base class with inaccessible destructor</li>
</ol>
<h3 id="checking-if-a-class-is-move-constructible">Checking if a class is move constructible<a class="headerlink" href="#checking-if-a-class-is-move-constructible" title="Permanent link">&para;</a></h3>
<p>We can check if a class is move constructible using the <a href="https://en.cppreference.com/w/cpp/types/is_move_constructible"><code>std::is_move_constructible</code></a> type trait. However, <strong>the <code>std::is_move_constructible</code> does not check if the move constructor is accessible!</strong> Instead it checks if the call to the move constructor is valid (can success, compiles). The call can success if the move constructor is accessible, but it can also success if it is not accessible, but the class has a copy constructor, which is used instead. </p>
<p>To check if the move constructor is accessible, we have to manually check the conditions, or disable the copy constructor. </p>
<h2 id="move-assignment">Move Assignment<a class="headerlink" href="#move-assignment" title="Permanent link">&para;</a></h2>
<h2 id="trivial-special-member-functions">Trivial special member functions<a class="headerlink" href="#trivial-special-member-functions" title="Permanent link">&para;</a></h2>
<p>The special member functions are called trivial if they contain no operations other then copying/moving the members and base classes. For a special member function of type <code>T</code> to be trivial, all of the following conditions must be true:</p>
<ul>
<li>it is implicitly-declared or defaulted</li>
<li><code>T</code> has no virtual functions</li>
<li><code>T</code> has no virtual base classes</li>
<li>the constructor for all direct base classes is trivial</li>
<li>the constructor for all non-static data members is trivial</li>
</ul>
<h2 id="destructor">Destructor<a class="headerlink" href="#destructor" title="Permanent link">&para;</a></h2>
<p>We need destructor only if the object owns some resources that needs to be manually deallocated</p>
<h2 id="typical-usage">Typical usage<a class="headerlink" href="#typical-usage" title="Permanent link">&para;</a></h2>
<p>It's mostly better to delete everything you don’t need. Most likely, either
- we need no custom constructors, or we need three (move and destructor), or we need all of them.</p>
<h3 id="simple-temporary-object">Simple Temporary Object<a class="headerlink" href="#simple-temporary-object" title="Permanent link">&para;</a></h3>
<ul>
<li>the object should live only in some local context</li>
<li>we don’t need anything</li>
</ul>
<h3 id="unique-object">Unique Object<a class="headerlink" href="#unique-object" title="Permanent link">&para;</a></h3>
<ul>
<li>usually represents some real object</li>
<li>usually, we need constructors for passing the ownership:<ul>
<li>move constructor</li>
<li>move assignment</li>
</ul>
</li>
</ul>
<h3 id="default-object">Default Object<a class="headerlink" href="#default-object" title="Permanent link">&para;</a></h3>
<ul>
<li>copyable object</li>
<li>We need<ul>
<li>copy constructor</li>
<li>copy assignment</li>
<li>move constructor</li>
<li>move assignment</li>
</ul>
</li>
</ul>
<h1 id="const-vs-non-const">Const vs non-const<a class="headerlink" href="#const-vs-non-const" title="Permanent link">&para;</a></h1>
<p>The <code>const</code> keyword makes the object non-mutable. This means that:</p>
<ul>
<li>it cannot be reassigned</li>
<li>non-const member functions of the object cannot be called</li>
</ul>
<p>The const keyword is usually used for local variables, function parameters, etc.</p>
<p><strong>For members, the const keyword should not be used</strong>, as it sometimes breaks the move operations on the object. For example we cannot move from a const <code>std::unique_ptr&lt;T&gt;</code> object. While this is also true for local variable, in members, it can lead to hard to find compilation errors, as a single const <code>std::unique_ptr&lt;T&gt;</code>  member deep in the object hierarchy breaks the move semantic for the whole class and all subclasses.</p>
<h2 id="avoiding-duplication-between-const-and-non-const-version-of-the-same-function">Avoiding duplication between const and non-const version of the same function<a class="headerlink" href="#avoiding-duplication-between-const-and-non-const-version-of-the-same-function" title="Permanent link">&para;</a></h2>
<p>To solve this problem without threatening the const-correctness, we need to implement the <em>const</em> version of a function and call it from the non-const one with double type cast:</p>
<ul>
<li>one that converts <em>this</em> to const, so we can call the const version of the function</li>
<li>another one that removes const from the return value</li>
</ul>
<p>Example:</p>
<pre><code class="language-cpp">const Content&amp; get_content(unsigned index) const {
    Content content = ... // complicated code to get the right content
    return content;
}

Content&amp; get_content(unsigned index){
    return const_cast&lt;Content&amp;&gt;(std::as_const(this*).get_content());
}

</code></pre>
<h2 id="constnon-const-overloads-and-inheritance">Const/non const overloads and inheritance<a class="headerlink" href="#constnon-const-overloads-and-inheritance" title="Permanent link">&para;</a></h2>
<p>Normally, the compiler can safely choose the best match between const and non-const overloads. The problem can happen when each version is in a different place in the class hierarchy. Example:</p>
<pre><code class="language-cpp">class Base {
public:
    const int&amp; get() const {
    return some;
  }
protected:
  int some;
};

class A : public virtual Base {
public:
  int&amp; get() {
    return some;
  }
};

class B : public A {};

B test;
test.get(); // ambiguous function error
</code></pre>
<p>The problem is that the overload set is created for each class in the hierarchy separately. So if the overload was resolved prior the virtual function resolution, we would have only one version (non-const), which would be chosen, despite not being the best overload match in both overload sets. To prevent such unexpected result, some compilers (GCC) raise an ambiguous function error in such situations.</p>
<p>To resolve that, we can merge the overload sets in class <code>B</code>:</p>
<pre><code class="language-cpp">class B : public A {
    using Base:get;
    using A:get;
};
</code></pre>
<h1 id="io-and-filesystem">IO and Filesystem<a class="headerlink" href="#io-and-filesystem" title="Permanent link">&para;</a></h1>
<p>The simple way to print to standard input is:</p>
<pre><code class="language-cpp">std::cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; std::endl;
</code></pre>
<p>To return to the begining of the line and overwrite the previous output, we can use the <code>'\r'</code> character:</p>
<pre><code class="language-cpp">std::cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; '\r' &lt;&lt; std::flush;
</code></pre>
<h2 id="file-path-manipulation">File path manipulation<a class="headerlink" href="#file-path-manipulation" title="Permanent link">&para;</a></h2>
<p>Although we can use strings to work with file paths in C++, the standard format which is also easy to use is <a href="https://en.cppreference.com/w/cpp/filesystem/path"><code>std::filesystem::path</code></a> from the <a href="https://en.cppreference.com/w/cpp/filesystem">filesystem library</a>.</p>
<p>Basic operations:</p>
<ul>
<li>To <strong>create a path</strong>, we jusct call <code>std::filesystem::path(&lt;string path&gt;)</code>.</li>
<li>We can easily <strong>join two paths</strong> by <code>auto full_path = &lt;path 1&gt; / &lt;path 2&gt;</code>;</li>
<li>To get the <strong>asolute path</strong>, we call<ul>
<li><a href="https://en.cppreference.com/w/cpp/filesystem/absolute"><code>std::filesystem::absolute(&lt;path&gt;)</code></a> to get the path as <code>CWD/&lt;path&gt;</code></li>
<li><a href="https://en.cppreference.com/w/cpp/filesystem/canonical"><code>std::filesystem::canonical(&lt;path&gt;)</code></a> to get the dots resolved. Note that this method throws exception if the path does not exists.</li>
</ul>
</li>
<li>The path to the <strong>current working directory</strong> can be obtained by calling <code>std::filesystem::current_path()</code> and set using <code>std::filesystem::current_path(&lt;path&gt;)</code>.</li>
<li>To change the file extension (in the C++ representation, not in the filesystem), we can call the <a href="https://en.cppreference.com/w/cpp/filesystem/path/replace_extension"><code>replace_extension</code></a> method.</li>
</ul>
<h2 id="filesystem-manipulation">Filesystem manipulation<a class="headerlink" href="#filesystem-manipulation" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/filesystem">cppreference</a> </p>
<h3 id="copying">Copying<a class="headerlink" href="#copying" title="Permanent link">&para;</a></h3>
<p>To copy, we can use <a href="https://en.cppreference.com/w/cpp/filesystem/copy"><code>std::filesystem::copy(&lt;source path&gt;, &lt;destination path&gt;[, &lt;options&gt;])</code></a> function.</p>
<p>The options parameter type is <a href="https://en.cppreference.com/w/cpp/filesystem/copy_options"><code>std::filesystem::copy_options</code></a>. This enum is a bitmask type, therefore, multiple options can be combined using the <code>|</code> operator. Example:</p>
<pre><code class="language-cpp">auto options = std::filesystem::copy_options::recursive | std::filesystem::copy_options::overwrite_existing;

std::filesystem::copy(&quot;C:/temp/data&quot;, &quot;c:/data/new&quot;, options);
</code></pre>
<p>Note that <strong>unlike the unix <code>cp</code> command, the <code>copy</code> function does not copy the directoy itself</strong>, even if the destination directory exists. Suppose we have two direcories:</p>
<ul>
<li><code>C:/temp/new</code> </li>
<li><code>C:/data/</code></li>
</ul>
<p>And we want to copy the <code>new</code> folder, so that the result is: <code>C:/data/new/</code>. In bash, this will be:</p>
<pre><code class="language-bash">cp -r C:/temp/new C:/data/
</code></pre>
<p>While in C++, we need to do:</p>
<pre><code class="language-cpp">std::filesystem::copy(&quot;C:/temp/new&quot;, &quot;C:/data/new&quot;,  std::filesystem::copy_options::recursive);
</code></pre>
<h3 id="creating-directories">Creating directories<a class="headerlink" href="#creating-directories" title="Permanent link">&para;</a></h3>
<p>To create a directory, we can use <a href="https://en.cppreference.com/w/cpp/filesystem/create_directory"><code>std::filesystem::create_directory(&lt;path&gt;)</code></a> function. </p>
<p>This function fails if the parent directory does not exist. To create the parent directories as well, we can use <a href="https://en.cppreference.com/w/cpp/filesystem/create_directory"><code>std::filesystem::create_directories(&lt;path&gt;)</code></a> function.</p>
<h3 id="removing-files-and-directories">Removing files and directories<a class="headerlink" href="#removing-files-and-directories" title="Permanent link">&para;</a></h3>
<p>To remove a file or an empty directory, we can use <a href="https://en.cppreference.com/w/cpp/filesystem/remove"><code>std::filesystem::remove(&lt;path&gt;)</code></a> function.</p>
<p>To remove a content of a directory we can use <code>std::filesystem::remove_all(&lt;path&gt;)</code> function listed on the same page of cppreference.</p>
<h3 id="other-useful-functions">Other useful functions<a class="headerlink" href="#other-useful-functions" title="Permanent link">&para;</a></h3>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/filesystem/exists"><code>std::filesystem::exists(&lt;path&gt;)</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/filesystem/is_directory"><code>std::filesystem::is_directory(&lt;path&gt;)</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/filesystem/is_regular_file"><code>std::filesystem::is_regular_file(&lt;path&gt;)</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/filesystem/is_empty"><code>std::filesystem::is_empty(&lt;path&gt;)</code></a></li>
</ul>
<h2 id="manual-text-io">Manual text IO<a class="headerlink" href="#manual-text-io" title="Permanent link">&para;</a></h2>
<h3 id="input">Input<a class="headerlink" href="#input" title="Permanent link">&para;</a></h3>
<p>For input, we can use <a href="https://en.cppreference.com/w/cpp/io/basic_ifstream"><code>std::ifstream</code></a>:</p>
<pre><code class="language-cpp">std::ifstream file;
file.open(&lt;path&gt;);
...
file.close();
</code></pre>
<p>The important thing is that we need to check whether the <code>open</code> call was successful. <strong>The <code>open</code> function never throws an exception, even if the file does not exist</strong>, which is a common case. Instead, it only sets the <code>failbit</code> of the stream. Without some check, the failure is hidden as an ifstream  in a fail state behaves as if it was empty.</p>
<p>For reading <strong>line by line</strong>, we can use the <code>std::getline</code> function:</p>
<pre><code class="language-cpp">std::string line;
while (std::getline(file, line)) {
    // do something with the line
}
</code></pre>
<p>However, processing the line is currently not very convenient in C++ because functions from other languages like <code>split</code> are missing.</p>
<p>For <strong>reading whitespace delimited tokens</strong> we can instead use the <a href="https://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt"><code>&gt;&gt;</code> operator</a> on the stream:</p>
<pre><code class="language-cpp">// file content: &quot;01 Smith&quot;

int id;
std::string name;

file &gt;&gt; id &gt;&gt; name;
</code></pre>
<p>If we need to skip some tokens, its best to introduce a dummy string variable:</p>
<pre><code class="language-cpp">// file content: &quot;01 2021-01-01 active Smith&quot;

int id;
std::string dummy;
std::string name;

file &gt;&gt; id &gt;&gt; dummy &gt;&gt; dummy &gt;&gt; name;
</code></pre>
<p>Conveniently, the input streams have a <code>bool</code> operator that states whether the stream is in a state ready for reading. This way, we can easily stop the loop when the file is read, because the <code>&gt;&gt;</code> operator returns the stream itself:</p>
<pre><code class="language-cpp">// read the whole file
while (file &gt;&gt; id &gt;&gt; name) {
    ...
}
</code></pre>
<h3 id="output">Output<a class="headerlink" href="#output" title="Permanent link">&para;</a></h3>
<p>For line by line output, we use <code>std::ofstream</code>:</p>
<pre><code class="language-cpp">std::ofstream file;
file.open(&lt;path&gt;);
batch_file &lt;&lt; &quot;first line&quot; &lt;&lt; std::endl;
batch_file &lt;&lt; &quot;second line&quot; &lt;&lt; std::endl;
...
batch_file.close();
</code></pre>
<h2 id="load-whole-file-into-string">Load whole file into string<a class="headerlink" href="#load-whole-file-into-string" title="Permanent link">&para;</a></h2>
<p>Again, we use the <code>std::ifstream</code>, but this time, we also use the <code>std::istreambuf_iterator</code> to read the whole file into a string:</p>
<pre><code class="language-cpp">std::ifstream file(&lt;path&gt;);
std::string content(std::istreambuf_iterator&lt;char&gt;{file}, {});
</code></pre>
<p>Here, the <code>std::istreambuf_iterator&lt;char&gt;</code> is created using initialization instead of the constructor so that the local variable is not confused with function declaration. The <code>{}</code> is used to create an empty string, which is the end of the range for the iterator.</p>
<h2 id="csv">csv<a class="headerlink" href="#csv" title="Permanent link">&para;</a></h2>
<h3 id="input_1">Input<a class="headerlink" href="#input_1" title="Permanent link">&para;</a></h3>
<h3 id="output_1">Output<a class="headerlink" href="#output_1" title="Permanent link">&para;</a></h3>
<p>For csv output, we can usually use the general line-by-line approach.</p>
<h2 id="yaml">YAML<a class="headerlink" href="#yaml" title="Permanent link">&para;</a></h2>
<p>For YAML, we can use the <a href="https://github.com/jbeder/yaml-cpp/">yaml-cpp</a> library. We can load</p>
<ul>
<li>from file using <code>YAML::LoadFile(&lt;path&gt;)</code></li>
<li>from string using <code>YAML::Load(&lt;string&gt;)</code><ul>
<li>for some reason, the <code>YAML::Load</code> function does not work with objects separated by indentation, so we need to use <code>{}</code> to separate the objects. </li>
</ul>
</li>
</ul>
<p>To test whether a <code>YAML::Node</code> <strong>contains a certain key</strong>, we may use the <code>[]</code> operator, as it does not create a new node (unlike the stl containers):</p>
<pre><code class="language-cpp">YAML::Node node;
if (node[&quot;key&quot;]) {
    // do something
}
</code></pre>
<p>The <strong>iteration</strong> over the keys is done using <code>YAML::const_iterator</code>:</p>
<pre><code class="language-cpp">for (YAML::const_iterator it = node.begin(); it != node.end(); ++it) {
    std::string key = it-&gt;first.as&lt;std::string&gt;();
    YAML::Node value = it-&gt;second;
}
</code></pre>
<h2 id="hdf">HDF<a class="headerlink" href="#hdf" title="Permanent link">&para;</a></h2>
<p>To load data from HDF5 files, the HDF5 C++ API can be used. Typical usage:</p>
<pre><code class="language-cpp">#include &lt;H5Cpp.h&gt;

const H5::H5File file(&quot;file.h5&quot;, H5F_ACC_RDONLY);

const H5::DataSet dataset = file.openDataSet(&quot;dataset&quot;);
const H5::DataSpace dataspace = dataset.getSpace();
hsize_t dims[2];
dataspace.getSimpleExtentDims(dims);
H5::DataSpace memspace(2, dims);

dataset.read(
    &lt;pointer where to store the data&gt;,
    H5::PredType::&lt;data type&gt;,
    memspace,
    dataspace
);
</code></pre>
<p>If we do not know the dataset name, we can get the name by index:</p>
<pre><code class="language-cpp">std::string dataset_name = file.getObjnameByIdx(0); // get the first dataset name
</code></pre>
<p>To check if the dataset exists, we can use the <code>exists</code> method of the file:</p>
<pre><code class="language-cpp">const H5::H5File file(&quot;file.h5&quot;, H5F_ACC_RDONLY);
if (file.exists(&quot;dataset&quot;)) {
    ...
}
</code></pre>
<h1 id="inheritance">Inheritance<a class="headerlink" href="#inheritance" title="Permanent link">&para;</a></h1>
<p>Inheritance in C++ is similar to other languages, here are the important points:</p>
<ul>
<li>To enable overiding, a member function needs to be declared as <code>virtual</code>. Otherwise, it will be just hidden in a child with a function with the same name, and the <code>override</code> specifier cannot be used (see Shadowing).</li>
<li>Multiple inheritance is possible.</li>
<li>No interfaces. Instead, you can use abstract class with no data members.</li>
<li>Virtual functions without implementation needs <code>= 0</code> at the end of the declaration (e.g.: <code>virtual void print() = 0;</code>)</li>
<li>a type is polymorphic if it has at least one virtual function. I.e., the inheritance itself does not make the type polymorphic.</li>
</ul>
<h2 id="polymorphism">Polymorphism<a class="headerlink" href="#polymorphism" title="Permanent link">&para;</a></h2>
<p>Polymorphism is a concept for abstraction using which we can provide a single interface for multiple types that share the same parent. In C++, to use the polymorphism, <strong>we need to work with pointers or references</strong>. Imagine that we have these two class and a method that can process the base class:</p>
<pre><code class="language-c++">class Base {
};

class Derived: public Base {
};

void process_base(Base* base) {
}
</code></pre>
<p>Now we can use it lake this:</p>
<pre><code class="language-c++">Derived* derived = new Derived(); 
Base* base = derived; // we easilly can convert derived to base
process_base(base);
process_base(derived); // we can call the function that accepts a base pointer with a derived pointer
</code></pre>
<p>We can do the same with smart pointers:</p>
<pre><code class="language-c++">void process_base_sh(std::shared_ptr&lt;Base&gt; base) {
}

std::shared_ptr&lt;Derived&gt; derived_sh = std::make_shared&lt;Derived&gt;();
std::shared_ptr&lt;Base&gt; base_sh = derived_sh;

process_base_sh(base_sh);
process_base_sh(derived_sh);
</code></pre>
<h2 id="shadowinghiding-why-is-a-function-from-parent-not-available-in-child">Shadowing/Hiding: why is a function from parent not available in child?<a class="headerlink" href="#shadowinghiding-why-is-a-function-from-parent-not-available-in-child" title="Permanent link">&para;</a></h2>
<p>Members in child with a same name as another members in parent shadows those members (except the case when the parent member is virtual). When a member is shadowed/hiden, it is not available in the child class and it cannot be called using the child class instance. </p>
<p>This can be counter-intuitive for functions as <strong>the shadowing considers only the name, not the signature</strong>. Example:</p>
<pre><code class="language-c++">class Base {
public:
    void print() {
        printf(&quot;Base\n&quot;);
    }
};

class Child: public Base {
public:
    void print(std::string type) {
        printf(&quot;Child &quot; + type + &quot;\n&quot;);
    }
};

int main()
{
    Child child;
    child.print(); // does not compile, as the print() is hidden by print(std::string)
    return 0;
}
</code></pre>
<h3 id="how-to-call-a-hidden-function">How to call a hidden function?<a class="headerlink" href="#how-to-call-a-hidden-function" title="Permanent link">&para;</a></h3>
<p>There are two ways how to call a hideen function:</p>
<ol>
<li>
<p>we can use the <code>using</code> declaration in the child to introduce the hidden function:
    <code>c++
    class Child: public Base {
    public:
        using Base::print; // now the print() is available in Child
        void print(std::string type) {
            printf("Child " + type + "\n");
        }
    };</code></p>
</li>
<li>
<p>Usiang a <em>fully qualified name</em> of the method:
    <code>c++
    int main()
    {
        Child child;
        child.Base::print(); 
        return 0;
    }</code></p>
</li>
</ol>
<h2 id="constructors">Constructors<a class="headerlink" href="#constructors" title="Permanent link">&para;</a></h2>
<p>Parent constructor is always called from a child. By default, an empty constructor is called. Alternatively, we can call another constructor in the initializer. When we do not call the parent constructor in the child's initializer and the parent has no empty constructor, a compilation error is raised.</p>
<h3 id="enablinging-parent-constructors-in-child">Enablinging Parent Constructors in Child<a class="headerlink" href="#enablinging-parent-constructors-in-child" title="Permanent link">&para;</a></h3>
<p>Implicitly, all methods from parent classes are visible in child, with exception of constructors. Constructors can be inherited manually with a <code>using</code> declaration, but only all at once.
To enable only some constructors, we need to repeat them manually as child constructors and call parent construcors from them.</p>
<h3 id="inheritance-and-constructorsdestructors">Inheritance and Constructors/Destructors<a class="headerlink" href="#inheritance-and-constructorsdestructors" title="Permanent link">&para;</a></h3>
<p>To prevent the future bugs with polymorphic destruction calls, <strong>it's a good habit to declare a public virtual destructor in each base class</strong>:</p>
<pre><code class="language-C++">class Base{
public:
    virtual ~Base() = default;
}
</code></pre>
<p>Otherwise, the following code will not call the child destructor:</p>
<pre><code class="language-C++">Child* child = new Child();
Base* base = (Base) child;
delete base;
</code></pre>
<p>But when defining destructor, constructor and move operations are not impliciotely  generated. Moreover, the copy operations are generated enabling a polymorphic copy, which results in slicing.  Therefore, <strong>the best approach for the base class</strong> is to: </p>
<ul>
<li>declare the <strong>virtual destrucor</strong> as default</li>
<li>declare the <strong>default constructor</strong>. We need a default constructor, unless we use a diferent constructor and we want to disable the default one.</li>
<li>declare the <strong>copy and move operations as protected</strong>. This way, the polymorpic copy is not possible, but proper copy/move operations are generated for every child class.  </li>
</ul>
<h3 id="initializing-base-class-members">Initializing base class members<a class="headerlink" href="#initializing-base-class-members" title="Permanent link">&para;</a></h3>
<p>The base class members cannot be initialized in the child constructor initializer. Instead, we need to create a constructor in the base class and call it from the child constructor initializer.</p>
<h2 id="slicing">Slicing<a class="headerlink" href="#slicing" title="Permanent link">&para;</a></h2>
<p>Polymorphism does not go well with value types. When a value type is copied, the only part that remains is the part writen in the code. That means that copying <code>base_2 = base_1</code> result in a new <code>Base</code> object in <code>base_2</code>, even if <code>base_1</code> is an instance of child. <strong>Abstract classes therefore cannot be used as function value arguments at all</strong>.</p>
<p>To pass a polymorphic type as a value to a library function, we need a copyable wrapper that forwards all calls to the undelying polymorphic type.</p>
<h2 id="checking-the-type">Checking the Type<a class="headerlink" href="#checking-the-type" title="Permanent link">&para;</a></h2>
<p>There is no equivalent of Java's <code>instanceof</code> in C++. To check the type. it is possible to use dynamic cast:</p>
<pre><code class="language-C++">Child&amp; child = dynamic_cast&lt;Child&amp;&gt;(parent)
</code></pre>
<p>In case of failure, <code>std::bad_cast</code> is thrown. To prevent exceptions (i.e., we need the type check for branching), we can use pointers:</p>
<pre><code class="language-C++">Child* child = dynamic_cast&lt;Child*&gt;(&amp;parent)
</code></pre>
<p>In this case, if the cast fails, then <code>child == nullptr</code>.</p>
<p><strong>Note that to use the <code>dynamic_cast</code> on a type, the type, the type needs to have at least one virtual method</strong>. However, this should not be an issue as the type should have at least a virtual destructor.</p>
<h2 id="covariant-return-type">Covariant Return Type<a class="headerlink" href="#covariant-return-type" title="Permanent link">&para;</a></h2>
<p>Covariant return type is a concept of returning a narower type id derived class than the return type specified in base. Example:</p>
<pre><code class="language-c++">class Base {
public:
    virtual Base&amp; get() = 0;
};

class Derived: public Base{
public:
    Derived&amp; get() override {
        return *this;
    }
};
</code></pre>
<p>It works with template classes too:</p>
<pre><code class="language-c++">template&lt;class T&gt;
class Derived_template: public Base {
public:
    Derived_template&lt;T&gt;&amp; get() override {
        return &amp;this;
    }
};
</code></pre>
<h2 id="use-method-from-parent-to-override-a-method-from-other-parent">Use Method from Parent to Override a Method from Other Parent<a class="headerlink" href="#use-method-from-parent-to-override-a-method-from-other-parent" title="Permanent link">&para;</a></h2>
<p>Unlike in java, <strong>a parent method cannot be used to implement an interface of a child</strong>. Example:</p>
<pre><code class="language-c++">class Interface {
public:
    virtual void print() = 0;
};

class Base {
public:
    virtual void print() {
        printf(&quot;Base\n&quot;);
    }
};

class Child: public Base, public Interface {
public:

};

int main()
{
    Child child; // does not compile, as Child is an abstract class

    child.print();
    return 0;
}
</code></pre>
<p>The above code does not compile as in C++, the parent <code>print()</code> method is not used as an impementation of <code>print()</code> from the interface (like it works e.g. in Java).</p>
<p>There simplest solution to this problem is to override the method in <code>Child</code> and call the parent method staticaly:</p>
<pre><code class="language-c++">class Child: public Base, public Interface {
public:
    void print() override {
        Base::print();
    }
};
</code></pre>
<h2 id="multiple-inheritance-and-virtual-base-classes">Multiple inheritance and virtual base classes<a class="headerlink" href="#multiple-inheritance-and-virtual-base-classes" title="Permanent link">&para;</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Virtual_inheritance">wiki</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/derived_class#Virtual_base_classes">cppreference</a></p>
<p>Multiple inheritance is possible in C++. However, it can lead to some problems.
Consider the following example:</p>
<pre><code class="language-c++">class A {
public:
    int a;
};

class B: public A {};

class C: public A {};

class D: public B, public C {};
</code></pre>
<p>It may not be obvious, but the <strong>class <code>D</code> has two instances of <code>A</code></strong> in it. This is because the <code>B</code> and <code>C</code> both have their own instance of <code>A</code>. This is certainly not what we want as this way, we have two copies of <code>A::a</code> in <code>D</code>, which are only accessible using qualified names (<code>D::B::a</code> and <code>D::C::a</code>) and which can have different values. </p>
<h3 id="virtual-inheritance">Virtual Inheritance<a class="headerlink" href="#virtual-inheritance" title="Permanent link">&para;</a></h3>
<p>To mitigate this problem, we can use the <em>virtual inheritance</em>. The virtual inheritance is used when we want to have only one instance of a base class in a child class, even if the base class is inherited multiple times. To use the virtual inheritance, we need to declare the base class as virtual in all child classes:</p>
<pre><code class="language-c++">class A {
public:
    int a;
};

class B: public virtual A {};

class C: public virtual A {};

class D: public B, public C {};
</code></pre>
<h3 id="multiple-copymove-calls-with-virtual-inheritance">Multiple copy/move calls with virtual inheritance<a class="headerlink" href="#multiple-copymove-calls-with-virtual-inheritance" title="Permanent link">&para;</a></h3>
<p>However, this solves only the problem of having multiple instances of the same base class. But there are also problems with the copy and move operations. In the above example, if the class <code>D</code> is copied or moved, it calls the copy/move operations of <code>B</code> and <code>C</code>, which in turn call the copy/move operations of <code>A</code>. <strong>This means that the <code>A</code> is copied/moved twice</strong>, which is not what we want.</p>
<p>To solve this we need to manually define the copy/move operations of classes in the hierarchy so that the copy/move operations of the base class are called only once. However this can be a complex task. Also, it can backfire later when we extend the hierarchy.</p>
<h3 id="other-sources">Other sources<a class="headerlink" href="#other-sources" title="Permanent link">&para;</a></h3>
<ul>
<li><a href="https://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance/407928#407928">SO answer</a></li>
<li><a href="https://stackoverflow.com/questions/21558/in-c-what-is-a-virtual-base-class/21607#21607">SO answer 2</a></li>
</ul>
<h1 id="templates">Templates<a class="headerlink" href="#templates" title="Permanent link">&para;</a></h1>
<p>The templates are a powerful tool for:</p>
<ul>
<li>generic programming,</li>
<li>zero-overhead interfaces,</li>
<li>and metaprogramming.</li>
</ul>
<p>Although they have similar syntax as generics in Java, they are principialy different both in the way they are implemented and in the way they are used.</p>
<p>There are two types of templates:</p>
<ul>
<li>function templates</li>
<li>class templates</li>
</ul>
<h2 id="syntax">Syntax<a class="headerlink" href="#syntax" title="Permanent link">&para;</a></h2>
<h3 id="template-declaration">Template Declaration<a class="headerlink" href="#template-declaration" title="Permanent link">&para;</a></h3>
<p>Both for classes and functions, the template declaration has the following form:</p>
<pre><code class="language-cpp">template&lt;&lt;template parameters&gt;&gt;
</code></pre>
<p>The template parameters can be:</p>
<ul>
<li>type parameters: <code>class T</code></li>
<li>value parameters: <code>int N</code></li>
<li>concept parameters: <code>std::integral T</code></li>
</ul>
<h3 id="template-definition">Template definition<a class="headerlink" href="#template-definition" title="Permanent link">&para;</a></h3>
<p>The definition of template functions or functions fo the template class requires the template declaration to be present. The definition has the following form:</p>
<pre><code class="language-cpp">template&lt;&lt;template parameters&gt;&gt;
&lt;standard function definition&gt;
</code></pre>
<p>Here, the template parameters are the function template parameters if we define a template function, or the class template parameters if we define a function of a template class.</p>
<p>If the template function is a member of a template class, we have to specify both the template parameters of the function and the template parameters of the class:</p>
<pre><code class="language-cpp">template&lt;&lt;class template parameters&gt;&gt;
template&lt;&lt;function template parameters&gt;&gt;
&lt;standard class function definition&gt;
</code></pre>
<p>Note that the <strong>template definition has to be in the header file</strong>, either directly or included from another header file. This includes the member function definitions of a template class, even if they are not templated themselves and does not use the template parameters of the class.</p>
<h2 id="organization-rules">Organization rules<a class="headerlink" href="#organization-rules" title="Permanent link">&para;</a></h2>
<ul>
<li><code>*.h</code>: declarations</li>
<li><code>*.tpp</code> template definitions</li>
<li><code>*.cpp</code> non-template definitions.</li>
</ul>
<p>For simplicity, we include the <code>tpp</code> files at the end of corresponding header files. If we need to speed up the compilation, we can include the <code>tpp</code> files only in the source files that needs the implementations , as described on <a href="https://softwareengineering.stackexchange.com/questions/373916/c-preferred-method-of-dealing-with-implementation-for-large-templates">SE</a></p>
<p>To speed up the build it <strong>is also desireble to move any non-template code to source files</strong>, even through inheritance, if needed.</p>
<h2 id="providing-template-arguments">Providing Template Arguments<a class="headerlink" href="#providing-template-arguments" title="Permanent link">&para;</a></h2>
<p>A template can be instantiated only if all the template arguments are provided.</p>
<p>The <strong>templete arguments need to be complete types</strong>.</p>
<p>Arguments can be</p>
<ul>
<li>provided explicitly: <code>std::vector&lt;int&gt; v;</code> or <code>sum&lt;int&gt;(1,2)</code>,</li>
<li>deduced<ul>
<li>from the initialization (classes): <code>std::vector v = {1,2,3};</code></li>
<li>from the context (functions): <code>sum(1,2);</code>, or</li>
</ul>
</li>
<li>
<p>defaulted</p>
<p>```cpp
template<class T = int>
class A {};</p>
<p>template<class T = int>
int sum<T>(T a, T b = 0) {
    return a + b;
}</p>
<p>auto s = sum(1, 2);</p>
<p>A a();
```</p>
</li>
</ul>
<p>If we want the template arguments to be deduced or defaulted, we usually  use the <code>&lt;&gt;</code>:</p>
<pre><code class="language-cpp">template&lt;class T = int&gt;
class A {};

A&lt;&gt; a(); // default argument is used
std::vector&lt;A&lt;&gt;&gt; v; // default argument is used 
</code></pre>
<p>In some cases, the <code>&lt;&gt;</code> can be ommited, e.g., when declaring a variable:</p>
<pre><code class="language-cpp">A a; // default argument is used

// but
std::vector&lt;A&gt; v; // error, the A is considered a template here, not the instantiation
</code></pre>
<p>The rules for omitting the <code>&lt;&gt;</code> are quite complex. Therefore, <strong>it is better to always use the <code>&lt;&gt;</code></strong> when we want to use the default arguments.</p>
<h3 id="rules-for-omitting-the">Rules for omitting the <code>&lt;&gt;</code><a class="headerlink" href="#rules-for-omitting-the" title="Permanent link">&para;</a></h3>
<p>We can ommite the <code>&lt;&gt;</code> in the following cases:</p>
<ul>
<li>when declaring a variable: <code>A a;</code></li>
<li>when using the type in a function call: <code>f(A());</code></li>
<li>when instantiating a template class: <code>class B: public A {};</code></li>
</ul>
<p>We cannot ommite the <code>&lt;&gt;</code> in the following cases:</p>
<ul>
<li>When we use the template as a nested type: <code>std::vector&lt;A&lt;&gt;&gt; v;</code>, not <code>std::vector&lt;A&gt; v;</code></li>
<li>in the return type of a function: <code>A&lt;&gt; f()</code>, not <code>A f()</code></li>
<li>When declaring an alias: <code>using B = A&lt;&gt;</code> not <code>using B = A</code></li>
<li>for template template parameters.</li>
</ul>
<h3 id="default-template-arguments">Default Template Arguments<a class="headerlink" href="#default-template-arguments" title="Permanent link">&para;</a></h3>
<p>Default template arguments can be used to provide a default value for any template parameter except parameter packs. </p>
<p>For template classes, there is a restriction that after a default argument is used, all the following parameters must have a default argument as well, except the last one wchich can be parameter pack. </p>
<h2 id="template-argument-deduction">Template Argument Deduction<a class="headerlink" href="#template-argument-deduction" title="Permanent link">&para;</a></h2>
<p>Details on <a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">cppreference</a>.</p>
<p>Template argument deduction should work for:</p>
<ul>
<li>constructors</li>
<li>function and operator calls</li>
<li>storing the function pointer</li>
</ul>
<h2 id="class-template-argument-deduction-ctad">Class Template Argument Deduction (CTAD)<a class="headerlink" href="#class-template-argument-deduction-ctad" title="Permanent link">&para;</a></h2>
<p>Details on <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">cppreference</a>.</p>
<p>The main difference from the function templete argument deduction is that in CTAD, all the template arguments needs to be specified, or all must not be specified and must be deducible.</p>
<p>Apart from that, there are more subtle differences arising of a complex procedure that is behind CTAD. We explain CTAD principle using a new concept (not a C++ concept :) ) called <em>deduction guides</em>.</p>
<h3 id="deduction-guides">Deduction Guides<a class="headerlink" href="#deduction-guides" title="Permanent link">&para;</a></h3>
<p>The CTAD use so called <em>deductione guides</em> to deduce the template parameters. Deduction guides can be either implicit or explicit. To demonstrate the principle, let's first start with user-defined deduction guides.</p>
<h4 id="user-defined-deduction-guides">User defined deduction guides<a class="headerlink" href="#user-defined-deduction-guides" title="Permanent link">&para;</a></h4>
<p>Let's have an iterator wrapper class below:</p>
<pre><code class="language-cpp">template&lt;class E, Iterator&lt;E&gt; I&gt;
class Iter_wrapper{
public:
    explicit Iter_wrapper(I iterator){
    ...
    }
    ...
};
</code></pre>
<p>Here, the argument <code>E</code> cannot be deduced from argument <code>I</code>, despite the use of the <code>Iterator</code> concept may indicate otherwise. We can still enable the deduction by adding the following deduction guide:</p>
<pre><code class="language-cpp">template&lt;class I&gt; Iter_wrapper(I iterator) -&gt; Iter_wrapper&lt;decltype(*iterator),I&gt;;
</code></pre>
<p>Here, the part left from <code>-&gt;</code> represents the constructor call that should be guided, and the part right from <code>-&gt;</code> defines the argument types we want to deduce.</p>
<p>Some more details about user defined deduction guides are also on the <a href="https://devblogs.microsoft.com/cppblog/how-to-use-class-template-argument-deduction/">Microsoft Blog</a>.</p>
<h4 id="implicit-deduction-guides">Implicit deduction guides<a class="headerlink" href="#implicit-deduction-guides" title="Permanent link">&para;</a></h4>
<p>The vast majority of deduction guidedes used in CTAD are implicit. The most important implicit deduction guides are:</p>
<ul>
<li>constructor deduction guides</li>
<li>copy deduction guides</li>
</ul>
<p>The <strong>copy</strong> deduction guide has the following form:</p>
<pre><code>template&lt;&lt;class template parameters&gt;&gt; &lt;class&gt;(&lt;class&gt;&lt;class template parameters&gt; obj) -&gt; &lt;class&gt;&lt;class template parameters&gt;;
</code></pre>
<p>For a simple wrapper class:</p>
<pre><code class="language-cpp">template&lt;class C&gt;
class Wrapper{
    ...
}

template&lt;class C&gt; Wrapper(Wrapper&lt;C&gt; obj) -&gt; Wrapper&lt;C&gt;; // implicitelly defined copy deduction guide
</code></pre>
<p>The constructor deduction guides has the following form:</p>
<pre><code>template&lt;&lt;class template parameters&gt;&gt; &lt;class&gt;(&lt;constructor arguments&gt;) -&gt; &lt;class&gt;&lt;class template parameters&gt;;
</code></pre>
<p>For a simple wrapper class:</p>
<pre><code class="language-cpp">template&lt;class C&gt;
class Wrapper{
    Wrapper(T&amp;&amp; ref);
}

template&lt;class C&gt; Wrapper(C&amp;&amp;) -&gt; Wrapper&lt;C&gt;; // implicitelly defined constructor deduction guide
</code></pre>
<h4 id="deduction-guides-resolution">Deduction guides resolution<a class="headerlink" href="#deduction-guides-resolution" title="Permanent link">&para;</a></h4>
<p><strong>Note that CTAD is a process independent of the constructor overload!</strong>. First an appropriate deduction guide is used to deduce the class template argumnets, this process can fail if there is no guide. Only then, the overload resolution begins. </p>
<p>Most of the time, it is not so important and we can just look at the constructor that is chosen by the constructor overload resolution process and see the used deduction guids and consequently, the resulting template arguments. Sometimes, however, this simplified understanding can lead to confusing results:</p>
<pre><code class="language-cpp">template&lt;class C&gt;
class Wrapper{
    Wrapper(T&amp;&amp; ref);

    Wrapper(double&amp;&amp; ref); // special overload for double
}

auto w1 = Wrapper(1.5) // the double overload is called
</code></pre>
<p>In the above example, it may be surprising that the second constructor can be called, as it does not have the class argument present, so the implicit deduction guide cannot work:</p>
<pre><code class="language-cpp">template&lt;class C&gt; Wrapper(double&amp;&amp;) -&gt; Wrapper&lt;C&gt;; // C unknown! 
</code></pre>
<p>However, it compiles and works, because the deduction guide from the first constructor is used for CTAD, and then, the second constructor is chosen by the constructor overload.</p>
<h2 id="template-specialization">Template Specialization<a class="headerlink" href="#template-specialization" title="Permanent link">&para;</a></h2>
<p>Template specialization is a way to provide a different implementation of a template for a specific type. For example, we can provide a different implementation of a template for a <code>std::string</code> type. Imagine following class:</p>
<pre><code class="language-cpp">// declaration
template&lt;class T&gt;
class Object{
public:
    void print(T value)
};

// definition
template&lt;class T&gt;
void Object&lt;T&gt;::print(T value){
    std::cout &lt;&lt; value &lt;&lt; std::endl;
}
</code></pre>
<p>Now, we can provide a different implementation for <code>std::string</code>:</p>
<pre><code class="language-cpp">// declaration
template&lt;&gt;
class Object{
public:
    void print(std::string value)
};

template&lt;&gt;
void Object&lt;std::string&gt;::print(std::string value){
    std::cout &lt;&lt; value &lt;&lt; std::endl;
}
</code></pre>
<p>There are two types of template specialization:</p>
<ul>
<li><strong>full specialization</strong>: exact specification for all template arguments</li>
<li><a href="https://en.cppreference.com/w/cpp/language/partial_specialization"><strong>partial specialization</strong></a>: exact specification for a subset of template arguments and/or non-type template arguments</li>
</ul>
<p>To demonstrate the difference, let's have a look at the following example:</p>
<pre><code class="language-cpp">// declaration
template&lt;class T, class C&gt;
class Object{}; // primary template

// full specialization
template&lt;&gt;
class Object&lt;int, std::string&gt;{}; // full specialization

// partial specializations
template&lt;class C&gt;
class Object&lt;int, C&gt;{}; // not a full specialization, as C is not specified

template&lt;std::integral T, My_concept C&gt;
class Object&lt;T, C&gt;{}; // not a full specialization, types are not exactly specified
</code></pre>
<p>While behaving similarly, there are some important <strong>differences between the full and partial specialization</strong>:</p>
<ul>
<li>
<p><strong>Declaration and definition:</strong></p>
<ul>
<li>
<p>Full specialization is a new type. Therefore, it must be declared in the header and defined in the source file (<code>.cpp</code>).</p>
<ul>
<li>
<p>additionaly, if the full specialization is a member of a class, the declaration must be outside the class:
    ```cpp
    template&lt;&gt;
    class Object{
    public:
        // member function template
        template<class T>
        void print(T value){
            ... // template definition
        }</p>
<pre><code>// template full specialization declaration - wrong. This will not compile in GCC
template&lt;&gt;
void print(std::string value){
    ... // template definition
}
</code></pre>
<p>};</p>
<p>// template full specialization declaration - correct
template&lt;&gt;
void Object::print(std::string value);
```</p>
</li>
</ul>
</li>
<li>
<p>Partial specialization is still just a template, so it must be defined in the header file (<code>.h</code> or <code>.tpp</code>).</p>
</li>
<li><strong>For functions, we cannot provide a partial specialization</strong>. </li>
<li>For member functions we can solve this by specializing the whole class. </li>
<li>For free functions, we have to use other techniques like <a href="#compile-time-branching">compile-time branching</a>.</li>
</ul>
</li>
</ul>
<h2 id="templates-and-namespaces">Templates and Namespaces<a class="headerlink" href="#templates-and-namespaces" title="Permanent link">&para;</a></h2>
<p>If the templated code resides in a namespace, it can be tempting to save few lines of code by sorrounding both <code>.h</code> and <code>.tpp</code> files using one namespace expression:</p>
<pre><code class="language-cpp">// structs.h hile
namespace my_namespace {
    // declarations...

    #include 'structs.tpp'
}

// structs.tpp
    // definitions

</code></pre>
<p>However, this can confuse some IDEs (e.g., false positive errors in IntelliSense), so it is better to introduce the namespace in both files:</p>
<pre><code class="language-cpp">// structs.h hile
namespace my_namespace {
    // declarations...
}

#include 'structs.tpp'

// structs.tpp
namespace my_namespace {
    // definitions
}
</code></pre>
<p>Don't forget to close the file and reopen it after the change to clear the errors.</p>
<h2 id="using-complicated-types-as-template-arguments">Using Complicated Types as Template Arguments<a class="headerlink" href="#using-complicated-types-as-template-arguments" title="Permanent link">&para;</a></h2>
<p>Sometimes, it can be very tricky to determine the template argument we need in order to use the template. The correct argument can be for example a return value of some function,  templete function, or even member function of a template instanciation which has other templates as argument...</p>
<p>To make it easier, we can, istead of suplying the correct arguments, evaluate an expression that returns the correct type and then use the <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a> specifier.  For more info, see the <em>Determining Type from Expressions</em> section.</p>
<h1 id="type-traits">Type Traits<a class="headerlink" href="#type-traits" title="Permanent link">&para;</a></h1>
<p>The purpose of type traits is to create predicates involving teplate parameters. Using type traits, we can ask questios about template parameters. With the answer to these questions, we can even implement conditional compilation, i.e., select a correct template based on parameter type. Most of the STL type traits are defined in header <a href="https://en.cppreference.com/w/cpp/header/type_traits"><code>type_traits</code></a>.</p>
<p>A type trate is a template with a constant that holds the result of the predicate, i.e., the answer to the question.</p>
<p><a href="https://www.internalpointers.com/post/quick-primer-type-traits-modern-cpp">More about type traits</a></p>
<h2 id="usefull-type-traits">Usefull Type Traits<a class="headerlink" href="#usefull-type-traits" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/is_same"><code>std::is_same</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_base_of"><code>std::is_base_of</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_convertible"><code>std::is_convertible</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/conditional"><code>std::conditional</code></a>: enables if-else type selection</li>
</ul>
<h2 id="replacement-for-old-type-traits">Replacement for old type traits<a class="headerlink" href="#replacement-for-old-type-traits" title="Permanent link">&para;</a></h2>
<p>Some of the old type traits are no longer needed as they can be replaced by new language features, which are more readable and less error prone. Some examples:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if</code></a> can be replaced by concepts:</li>
</ul>
<pre><code class="language-cpp">
// old: enable_if
template&lt;class T&gt;
void f(T x, typename std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, void&gt; = 0) {
    std::cout &lt;&lt; x &lt;&lt; '\n';
}

// new: concepts
template&lt;std::integral T&gt;
void f(T x) {
    std::cout &lt;&lt; x &lt;&lt; '\n';
}
</code></pre>
<h1 id="concepts">Concepts<a class="headerlink" href="#concepts" title="Permanent link">&para;</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/constraints">cppreference</a></p>
<p>Concepts are named sets of requiremnets. They can be used instead of <code>class</code>/<code>typename</code> keywords to restrict the template types.</p>
<p>The syntax is:</p>
<pre><code class="language-cpp">template&lt;class T, ....&gt;
concept concept-name = constraint-expression
</code></pre>
<p>The concept can have multiple template parameters. The first one in the declaration stands for the concept itself, so it can be refered in the constraint expression. More template parameters can be optionally added and their purpose is to make the concept generic.</p>
<h2 id="constraints">Constraints<a class="headerlink" href="#constraints" title="Permanent link">&para;</a></h2>
<p>Constraints can be composed using <code>&amp;&amp;</code> and <code>||</code> operatos. For atomic constaints declaration, we can use:</p>
<ul>
<li>Type traits:</li>
</ul>
<pre><code class="language-cpp">template&lt;class T&gt;
concept Integral = std::is_integral&lt;T&gt;::value;
</code></pre>
<ul>
<li>Concepts: </li>
</ul>
<pre><code class="language-cpp">template&lt;class T&gt;
concept UnsignedIntegral = Integral&lt;T&gt; &amp;&amp; !SignedIntegral&lt;T&gt;;
</code></pre>
<ul>
<li>Requires expression:</li>
</ul>
<pre><code class="language-cpp">template&lt;typename T&gt;
concept Addable = requires (T x) { x + x; };
</code></pre>
<p>Either form we chose, the atomic constraint have to always evaluate to bool. </p>
<h2 id="requires-expression">Requires Expression<a class="headerlink" href="#requires-expression" title="Permanent link">&para;</a></h2>
<p>Requires expressions ar ethe most powerfull conctraints. The syntax is:</p>
<pre><code class="language-cpp">requires(parameter list){requirements}
</code></pre>
<p>There are four types of requirements that can appear in the requires expression:</p>
<ul>
<li>
<p><em>simple requiremnet</em>: a requirement that can contain any expression. Evaluates to true if the expression is valid.
    <code>cpp
    requires (T x) { x + x; };</code></p>
</li>
<li>
<p><em>type requirement</em>: a requiremnt checking the validity of a type:
    <code>cpp
    requires
    {
        typename T::inner; // required nested member name
        typename S&lt;T&gt;;     // required class template specialization
        typename Ref&lt;T&gt;;   // required alias template substitution
    };</code></p>
</li>
<li>
<p><em>compound requirement</em>: Checks the arguments and the return type of some call. It has the form: <code>{expression} -&gt; return-type-requirement;</code>
    <code>cpp
    requires(T x)
    {
        {*x} -&gt; std::convertible_to&lt;typename T::inner&gt;;
    }</code></p>
<ul>
<li>other <a href="#usefull-type-traits">useful type traits</a> can be used instead of <code>std::convertible_to</code>.</li>
</ul>
</li>
<li>
<p><em>Nested requirement</em>: a require expression inside another requires expression:
    <code>cpp
    requires(T a, size_t n)
    {
        requires Same&lt;T*, decltype(&amp;a)&gt;; // nested
    }</code></p>
</li>
</ul>
<h2 id="auto-filling-the-first-template-argument">Auto filling the first template argument<a class="headerlink" href="#auto-filling-the-first-template-argument" title="Permanent link">&para;</a></h2>
<p>Concepts have a special feature that their first argument can be autoffiled from outer context. Consequentlly, you then fill only the remaining arguments. Examples:</p>
<pre><code class="language-cpp">//When using the concept
template&lt;class T, class U&gt;
concept Derived = std::is_base_of&lt;U, T&gt;::value;

template&lt;Derived&lt;Base&gt; T&gt;
void f(T); // T is constrained by Derived&lt;T, Base&gt;

// When defining the concept
template&lt;typename S&gt;
concept Stock = requires(S stock) {
    // return value is constrained by std::same_as&lt;decltype(stock), double&gt;
    {stock.get_value()} -&gt; std::same_as&lt;double&gt;; 
}
</code></pre>
<h2 id="stl-concepts">STL Concepts<a class="headerlink" href="#stl-concepts" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/header/iterator">iterator concepts</a></li>
</ul>
<h2 id="usefull-patterns">Usefull Patterns<a class="headerlink" href="#usefull-patterns" title="Permanent link">&para;</a></h2>
<h3 id="constrain-a-template-argument">Constrain a Template Argument<a class="headerlink" href="#constrain-a-template-argument" title="Permanent link">&para;</a></h3>
<p>Imagine that you have a template function <code>load</code> and an abstract class <code>Loadable_interface</code> that works as an interface:</p>
<pre><code class="language-c++">class Loadable_interface{
    virtual void load() = 0;
};

template&lt;class T&gt;
void load(T to_load){
    ...
    to load.load()
    ...
};
</code></pre>
<p>Typically you want to constraint the template  argument <code>T</code> to the <code>Loadable_interface</code> type, so that other developer clearly see the interface requirement, and receives a clear error message if the requirement is not met. </p>
<p>In Java, we have an <code>extend</code> keyword for this purpose that can constraint the template argument. In C++, this can be solved with concepts. First we have to define a concept that requires the interface:</p>
<pre><code class="language-c++">template&lt;typename L&gt;
concept Loadable =
std::is_base_of_v&lt;Loadable_interface, L&gt;;
</code></pre>
<p>Than we can use the concept like this:</p>
<pre><code class="language-c++">template&lt;Loadable T&gt;
void load(T to_load){
    ...
    to load.load()
    ...
};
</code></pre>
<h2 id="constraint-a-concept-argument">Constraint a Concept Argument<a class="headerlink" href="#constraint-a-concept-argument" title="Permanent link">&para;</a></h2>
<p>Imagine that you have a concept <code>Loadable</code> that requires a method <code>load</code> to return a  type <code>T</code> restricted by a concept <code>Loadable_type</code>. One would expect to write the <code>loadable</code> concept like this:</p>
<pre><code class="language-c++">template&lt;typename L, Loadable_type LT&gt;
concept Loadable = 
requires(L loadable) {
    {loadable.load()} -&gt; LT;
};
</code></pre>
<p>However, this is not possible, as there is a rule that <strong>concept cannot not have associated constraints</strong>. The solution is to use an unrestricted template argument and constrain it inside the concept definition:</p>
<pre><code class="language-c++">template&lt;typename L, typename LT&gt;
concept Loadable =
Loadable_type&lt;LT&gt; &amp;&amp;
requires(L loadable) {
    {loadable.load()} -&gt; LT;
};
</code></pre>
<h2 id="sources">Sources<a class="headerlink" href="#sources" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/constraints">https://en.cppreference.com/w/cpp/language/constraints</a></p>
<p><a href="https://akrzemi1.wordpress.com/2020/01/29/requires-expression/">Requires expression explained</a></p>
<h1 id="interfaces">Interfaces<a class="headerlink" href="#interfaces" title="Permanent link">&para;</a></h1>
<p>In programming, an interface is usualy a set of requirements that restricts the function or template parameters, so that all types fulfiling the requiremnet can be used as arguments.</p>
<p>Therte are two ways how to create an interface in C++:</p>
<ul>
<li>using the <em>polymorphism</em></li>
<li>using <em>templates argument restriction</em></li>
</ul>
<p>While the polymorphism is easier to implement, the templating is more powerful and it has zero overhead. The most important thing is probably that despite these concepts can be used together in one application, not all "combinations" are allowed especialy when using tamplates and polymorphism in the same type.</p>
<p><strong>Note that in C++, polymorphism option work only for function argument restriction, but we cannot directly use it to constrain template arguments</strong> (unlike in Java). </p>
<p>To demonstrate all possible options, imagine an interface that constraints a type that it must have the following two functions:</p>
<pre><code class="language-cpp">int get_value();
void set_value(int date);
</code></pre>
<p>The following sections we will demonstrate how to achieve this using multiple techniques. </p>
<h2 id="interface-using-polymorfism">Interface using polymorfism<a class="headerlink" href="#interface-using-polymorfism" title="Permanent link">&para;</a></h2>
<p>Unlike in java, there are no <code>interface</code> types in C++. However, we can implement polymorfic interface using abstract class. The following class can be used as an interface:</p>
<pre><code class="language-cpp">class Value_interface{
    virtual int get_value() = 0;
    virtual void set_value(int date) = 0;
}
</code></pre>
<p>To use this interface as a fuction argument or return value, follow this example:</p>
<pre><code class="language-cpp">std::unique_ptr&lt;Value_interface&gt; increment(std::unique_ptr&lt;Value_interface&gt; orig_value){
    return orig_value-&gt;set_value(orig_value-&gt;get_value() + 1);
}
</code></pre>
<p>This system works in C++ because it supports multiple inheritance. Do not forget to use the <code>virtual</code> keyword, otherwise, the method cannot be overriden.
Note that unlike in other languages, <strong>in C++, the polymorphism cannot be directly use as a template (generic) interface.</strong> Therefore, we cannot use the polymorfism alone to restrict a type.</p>
<h2 id="using-template-argument-restriction-as-an-interface">Using template argument restriction as an interface<a class="headerlink" href="#using-template-argument-restriction-as-an-interface" title="Permanent link">&para;</a></h2>
<p>To use template argument restriction as an interface, we can use concepts. The following concept impose the same requirements as the interface from the polymorphism section:
To use template argument restriction as an interface, we can use concepts. The following concept impose the same requirements as the interface from the polymorphism section:</p>
<pre><code class="language-cpp">template&lt;class V&gt;
concept Value_interface = 
    requires(V value_interface){{value_interface.get_value()} -&gt; std::same_as&lt;int&gt;; }
    &amp;&amp; requires(V value_interface, int value){{value_interface.set_value(value)} -&gt; std::same_as&lt;void&gt;; }
</code></pre>
<p>Remember that <strong>the return type of the function has to defined by a concept</strong>,  the type cannot be used directly. Therefore, the following require statement is invalid:</p>
<pre><code class="language-cpp">requires{(V value_interface){value_interface.get_value()} -&gt; int; }
</code></pre>
<p>To use this interface as an template argument in class use:</p>
<pre><code class="language-cpp">template&lt;Value_interface V&gt;
class ...
</code></pre>
<p>And in function arguments and return types:</p>
<pre><code class="language-cpp">template&lt;Value_interface V&gt; V increment(V orig_value){
    return orig_value.set_value(orig_value.get_value() + 1);
</code></pre>
<h3 id="restricting-the-member-function-to-be-const">Restricting the member function to be const<a class="headerlink" href="#restricting-the-member-function-to-be-const" title="Permanent link">&para;</a></h3>
<p>To restrict the member function to be const, we neet to make the type value const in the requires expression:</p>
<pre><code class="language-cpp">template&lt;class V&gt;
concept Value_interface = requires{(const V value_interface) 
    {valvalue_interfaceue.get_value() -&gt; std::same_as&lt;int&gt;;};
};
</code></pre>
<h2 id="using-concepts-and-polymorphism-together-to-restrict-template-parameters-with-abstract-class">Using concepts and polymorphism together to restrict template parameters with abstract class<a class="headerlink" href="#using-concepts-and-polymorphism-together-to-restrict-template-parameters-with-abstract-class" title="Permanent link">&para;</a></h2>
<p>We cannot restrict template parameters by polymorphic interface directly, however, we can combine it with concept. The folowing concept can be used together with the interface from the polymorphic interface section:</p>
<pre><code class="language-cpp">template&lt;class V&gt;
concept Value_interface_concept = requires std::is_base_of&lt;Value_interface,V&gt;
</code></pre>
<p><strong>Neverthless, as much as this combination can seem to be clear and elegent, it brings some problems.</strong>. We can use concepts to imposed many interfaces on a single type, but with this solution, it can lead to a polymorphic hell. While there is no problem with two concepts that directly requires the same method to be present with abstract classes, this can be problematic.
Moreover, we will lose the zero overhead advantage of the concepts, as the polymorphism will be used to implement the interface.</p>
<h2 id="the-conflict-between-templates-and-polymorphism">The Conflict Between Templates and Polymorphism<a class="headerlink" href="#the-conflict-between-templates-and-polymorphism" title="Permanent link">&para;</a></h2>
<p>As described above, messing with polymorphism and templates together can be tricky. Some examples:</p>
<h3 id="no-virtual-member-function-with-template-parameters">No Virtual Member Function with Template Parameters<a class="headerlink" href="#no-virtual-member-function-with-template-parameters" title="Permanent link">&para;</a></h3>
<p>An example: a virtual (abstract) function cannot be a template function (<a href="https://en.cppreference.com/w/cpp/language/member_template">member template function</a> cannot be virtual), so it cannot use template parameters outside of those defined by the class template.</p>
<h3 id="polymorphism-cannot-be-used-inside-template-params">Polymorphism cannot be used inside template params<a class="headerlink" href="#polymorphism-cannot-be-used-inside-template-params" title="Permanent link">&para;</a></h3>
<p>If the functin accepts <code>MyContainer&lt;Animal&gt;</code> we cannot call it with <code>MyContainer&lt;Cat&gt;</code>, even if <code>Cat</code> is an instance of Animal.</p>
<h3 id="possible-solutions-for-conflicts">Possible solutions for conflicts<a class="headerlink" href="#possible-solutions-for-conflicts" title="Permanent link">&para;</a></h3>
<ul>
<li>do not use templates -&gt; more complicated polymorphism (<em>type erasure</em> for members/containers)</li>
<li>do not use polymorphism -&gt; use templates for interfaces</li>
<li>an <a href="https://www.sciencedirect.com/science/article/pii/S0167642309000021">adapter</a> can be used</li>
</ul>
<h2 id="polymorphic-members-and-containers">Polymorphic members and containers<a class="headerlink" href="#polymorphic-members-and-containers" title="Permanent link">&para;</a></h2>
<p>When we need to store various object in the same member or container, we can use both templates and polymorphism. However, both techniques has its limits, summarized in the table below:
| | Polymorphism | Templates |
| -- | -- | -- |
| The concrete type has to be known at compile time | <code>No</code> | <code>Yes</code>
| For multiple member initializations, the member can contain any element. | <code>No</code>, the elements have to share base class. | <code>Yes</code> |
| For a single initialization, the containar can contain multiple types of objects | <code>Yes</code>, if they have the same base class | <code>No</code> 
| We can work with value members | <code>No</code> | <code>Yes</code>
| When using the interface, we need to use downcasting and upcasting | <code>Yes</code> | <code>No</code></p>
<h2 id="deciding-between-template-and-polymorphism">Deciding between template and polymorphism<a class="headerlink" href="#deciding-between-template-and-polymorphism" title="Permanent link">&para;</a></h2>
<p>Frequently, we need some entity(class, function) to accept multiple objects through some interface. We have to decide, whether we use templates, or polymorphism for that interface. Some decision points:</p>
<ul>
<li>We need to return the same type we enter to the class/function -&gt; use templates</li>
<li>We have to access the interface (from outside) without knowing the exact type -&gt; use polymorphism</li>
<li>We need to restrict the member/parametr type in the child -&gt; use templates for the template parameter</li>
<li>if you need to fix the relation between method parameters/members or template arguments of thouse, you need to use templates </li>
<li>If there are space considerations, be aware that every parent class adds an 8 byte pointer to the atribute table</li>
</ul>
<p>In general, the polymorphic interface have the following adventages:</p>
<ul>
<li>easy to implement</li>
<li>easy to undestand</li>
<li>similar to what people know from other languages</li>
</ul>
<p>On the other hand, the interface using concepts has the following adventages:</p>
<ul>
<li>no need for type cast</li>
<li>all types check on compile time -&gt; no runtime errors</li>
<li>zero overhead</li>
<li>no object slicing -&gt; you don't have to use pointers when working with this kind of interface</li>
<li>we can save memory because we don't need the vtable pointers</li>
</ul>
<h1 id="iterators-stl-algorithms-and-ranges">Iterators, STL algorithms, and ranges<a class="headerlink" href="#iterators-stl-algorithms-and-ranges" title="Permanent link">&para;</a></h1>
<p>If we want to iterate over elements in some programming language, we need to fulfill some interface. In Java, this interface is called <code>Iterable</code>. Also, there is usually some interface that formalize the underlying work, in Java, for example, it is called <code>Iterator</code>. </p>
<p>In C++, however, the interface for iteration is not handled by polymorphism. Instead, it is handled using type traits and concepts. On top of that, there are multiple interfaces for iteration:</p>
<ul>
<li>legacy iteration, e.g., <code>for (auto it = v.begin(); it != v.end(); ++it)</code></li>
<li>STL algorithms, e.g., <code>std::find(v.begin(), v.end(), 42)</code></li>
<li>STL range algorithms, e.g., <code>std::ranges::find(v, 42)</code></li>
<li>STL range views, e.g., <code>std::ranges::views::filter(v, [](int x){return x &gt; 0;})</code></li>
</ul>
<p>The following table summarizes the differences between the interfaces:
|---| Plain iteration | STL algorithms | STL range algorithms | STL range views |
|---|---|---|---|---|
| <strong>Interface</strong> | type traits | type traits | concepts | concepts |
| <strong>Iteration</strong> | eager | eager | eager | lazy |
| <strong>Modify the underlying range</strong><em> | no | yes | yes | no |
| </em><em>Can work on temporaries</em>* | yes | yes | yes | no |</p>
<p>*If the operation modifies the data, i.e., sorting, shuffling, transforming, etc.</p>
<p>The examples below demonstrate the differences between the interfaces on the following task: create a vector of 10 elements with values 0,1,2,...,9, i.e., the same as Python <code>range(10)</code>.</p>
<pre><code class="language-cpp">// plain iteration
std::vector&lt;int&gt; vec(10);
int i = 0;
for (auto it = vec.begin(); it != vec.end(); ++it) {
    *it = i;
    ++i;
}

// legacy algorithm
std::vector&lt;int&gt; vec(10);
std::iota(vec.begin(), vec.end(), 0); // C++11 way, legacy interface using type traits

// range algorithm
std::vector&lt;int&gt; vec(10);
std::ranges::iota(vec.begin(), vec.end(), 0); // basically the same, but the constructor arguments are constrained with concepts

// same using adaptor
auto range = std::views::iota(0, 10);
std::vector vec{range.begin(), range.end()}; // in-place vector construction
</code></pre>
<h2 id="terminology">Terminology<a class="headerlink" href="#terminology" title="Permanent link">&para;</a></h2>
<ul>
<li><em>range</em>: the object we iterate over (Iterable in Java)</li>
<li><em>iterator</em>: the object which does the real work (Iterator in Java)</li>
</ul>
<p>Usually, a range is composed of two iterators:</p>
<ul>
<li><em>begin</em>: points to the beginning of the range, returned by <code>&lt;range_object&gt;.begin()</code></li>
<li><em>end</em>: points to the end of the object, returned by  <code>&lt;range_object&gt;.end()</code> </li>
</ul>
<p>Each iterator implements the dereference (<code>*</code>) operator that acces the element of the range the iterator is pointing to.</p>
<p>Depending on the iterator type, the iterator also supports other operations: <code>++</code>, <code>--</code> to iterate along the range, array index operator (<code>[]</code>) for random access, etc.</p>
<p>Most of the STL <em>collections</em> (vector, set,...) are also ranges.</p>
<h2 id="how-to-choose-the-correct-interface">How to choose the correct interface?<a class="headerlink" href="#how-to-choose-the-correct-interface" title="Permanent link">&para;</a></h2>
<p>when deciding which interface to use, we can use the following rules:</p>
<ol>
<li><strong>If the number of tasks and the complexity of the tasks is high, use the legacy iteration</strong>. It is hard to write a 20 line for loop with various function calls as algorithm or adaptor and the result would be hard to read.</li>
<li>Otherwise, <strong>if you need to preserve the original range as it is or you need to compose multiple operations, use the STL range adaptors</strong>. </li>
<li>Otherwise, <strong>use the STL range algorithms</strong>.</li>
</ol>
<p>Note that the in this guide, we do not consider the legacy STL algorithms. With the availability of the STL <em>range</em> algorithms, there is no reason to use the legacy algorithms, except for the backward compatibility or for the algorithms that are not yet implemented in the STL.</p>
<p>Also note that some STL algorithms are principially non-modifying, e.g., <code>std::ranges::find</code> or <code>std::ranges::count</code>. These algorithms logically do not have the adaptor equivalent.</p>
<h2 id="stl-ranges-and-views">STL ranges and views<a class="headerlink" href="#stl-ranges-and-views" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/ranges">https://en.cppreference.com/w/cpp/ranges</a></p>
<p>In C++ 20 there is a new range library that provides functional operations for iterators. It is similar to functional addon in Java 8.</p>
<p>As explained in the beginning of this chapter, there are two ways how to use the STL ranges:</p>
<ul>
<li>using the <a href="https://en.cppreference.com/w/cpp/ranges">range algorithms</a> (<code>ranges::&lt;alg name&gt;</code>) that are invoked eagerly.</li>
<li>using the <a href="https://en.cppreference.com/w/cpp/ranges/views">range views</a> (<code>ranges::views::&lt;view name&gt;</code>) that are invoked lazily.</li>
</ul>
<p>Note that the range algorithms and adaptors cannot produce result without an input, i.e., <strong>we always need a range or collection on which we want to apply our algorithm/view.</strong></p>
<h3 id="stl-range-views">STL range views<a class="headerlink" href="#stl-range-views" title="Permanent link">&para;</a></h3>
<p>The difference of range view to range algorithms is that the views are lazy, i.e., they do not produce any result until they are iterated over. This is similar to the Python generators. The advantage is that we can chain multiple views together and the result is computed only when we iterate over the final view.</p>
<p>Note that due to the lazy nature of the views, <strong>the underlying range has to be alive during the whole iteration</strong>. Therefore, we cannot use the views on temporaries, e.g., we cannot useviews directly in the constructor of a vector, or we cannot use the views on a temporary range returned by a function.</p>
<p>A custom view can be created so that it can be chained with STL views. However, it has to satisfy the <a href="https://en.cppreference.com/w/cpp/ranges/view">view concept</a>, and more importantly, it should satisfy the view semantic, i.e., it should be cheap to copy and move (without copying the underlying data).</p>
<h4 id="usefull-views">Usefull views<a class="headerlink" href="#usefull-views" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/ranges/iota_view"><code>std::views::iota</code></a>: generates a sequence of numbers</li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/filter_view"><code>std::views::filter</code></a>: filters the elements of the range</li>
</ul>
<h3 id="projections">Projections<a class="headerlink" href="#projections" title="Permanent link">&para;</a></h3>
<p>Unlike in Java, we cannot refer to member functions when lambda functions are required. However, we can use these member functions when the algorithm or adaptor has a <em>projection</em> parameter. Example:</p>
<pre><code class="language-cpp">struct Data {
    int a;
    std::string b;
    ...
};

std::vector&lt;Data&gt; data = get_data();

std::sort(data, {}, &amp;Data::b);
</code></pre>
<p>The trick here is that we can only provide the member that we want to use for sorting, but the sorting logic (<code>first &lt; second</code>...) is handeled by a standard comparator (the second argument initialized with <code>{}</code>).</p>
<p>We can have even more complicated projections that are not just references to member functions:</p>
<pre><code class="language-cpp">std::vector&lt;My_class&gt; objects = get_objects();
std::vector&lt;unsigned&gt; indexes = get_indexes(objects);
auto proj = [&amp;objects](std::size_t i) -&gt; const std::string&amp; { 
    return objects[i].get_name(); 
};
std::ranges::sort(indexes, {}, proj) // sort indexes using the property of objects
</code></pre>
<h3 id="useful-range-algorithms">Useful range algorithms<a class="headerlink" href="#useful-range-algorithms" title="Permanent link">&para;</a></h3>
<p>Note that the most frequently used algorithms have a separate section in the Iterators chapter.</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/random_shuffle"><code>std::shuffle</code></a> : shuffles the elements in the range (formerly <code>std::random_shuffle</code>).</li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_find"><code>std::adjacent_find</code></a> : finds the first two adjacent elements that are equal. Can be used to find duplicates if the range is sorted.</li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/unique"><code>std::ranges::unique</code></a>: moves the duplicates to the end of the range and returns the iterator to the first duplicate. Only consecutive duplicates are found.</li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/min"><code>std::ranges::min</code></a> : finds the smallest element in the range. We can use either natural sorting, or a comparator, or a projection. If the range is empty, the behavior is undefined.</li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/min_element"><code>std::ranges::min_element</code></a> : finds the smallest element in the range. Unlike <code>std::ranges::min</code>, this function returns an iterator to the smallest element. </li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/empty"><code>std::ranges::empty</code></a> : checks whether the range is empty. </li>
</ul>
<h3 id="other-resources">Other Resources<a class="headerlink" href="#other-resources" title="Permanent link">&para;</a></h3>
<ul>
<li><a href="https://www.modernescpp.com/index.php/c-20-the-ranges-library">https://www.modernescpp.com/index.php/c-20-the-ranges-library</a> </li>
</ul>
<h2 id="boost-ranges">Boost ranges<a class="headerlink" href="#boost-ranges" title="Permanent link">&para;</a></h2>
<p>In addition to the STL range algorithms and adaptors, boost has it's own <a href="https://www.boost.org/doc/libs/1_80_0/libs/range/doc/html/index.html">range library</a> with other more complex algorithms and adaptors.</p>
<h3 id="boost-range-requirements">Boost range requirements<a class="headerlink" href="#boost-range-requirements" title="Permanent link">&para;</a></h3>
<p>Sometimes, it is hard to say why a type does not satisfy some of the requirements for boos ranges. Fortunatelly, the boost provides concepts for checking whether a type satisfy each specific range model. Example:</p>
<pre><code class="language-cpp">BOOST_CONCEPT_ASSERT((
    boost::SinglePassRangeConcept&lt;std::vector&lt;int&gt;&gt;
)); // true
</code></pre>
<p>Also, it is necessary to check whether the value of the iterator can be accessed:</p>
<pre><code class="language-cpp">BOOST_CONCEPT_ASSERT((
    boost_concepts::ReadableIteratorConcept&lt;
        typename boost::range_iterator&lt;std::vector&lt;int&gt;&gt;::type
    &gt;
)); // true
</code></pre>
<p>Most likely, the compiler will complain that <code>boost::range_iterator&lt;R&gt;::type</code> does not exist for your range <code>R</code> . The boost range library generate this type by a macro from the <code>R::iterator</code> type. Therefore, make sure that your range has an iterator type defined, either as:</p>
<ul>
<li>a type alias to an existing iterator</li>
<li>an iterator nested class</li>
</ul>
<p>Note that <strong><code>&lt;RANGE CLASS&gt;::iterator</code> and <code>&lt;RANGE CLASS&gt;::const_iterator</code> has to be accessible (public).</strong></p>
<h2 id="sequences">Sequences<a class="headerlink" href="#sequences" title="Permanent link">&para;</a></h2>
<p>The <code>iota</code> algortihm/adapter is used to create a sequence:</p>
<pre><code class="language-cpp">auto range = std::views::iota(0, 10);
auto vec = std::vector(range.begin(), range.end());
</code></pre>
<p>Note that we cannot pass the view directly to the vector, as the vector does not have a range constructor.</p>
<h2 id="zip">Zip<a class="headerlink" href="#zip" title="Permanent link">&para;</a></h2>
<p>The classical Python like zip iteration is available using the <a href="https://en.cppreference.com/w/cpp/ranges/zip_view">zip adapator</a>, which is not yet supported in MSVC.</p>
<p>However, boost provides a similar functionality <code>boost::combine</code>.</p>
<h3 id="boostcombine"><code>boost::combine</code><a class="headerlink" href="#boostcombine" title="Permanent link">&para;</a></h3>
<p><a href="https://www.boost.org/doc/libs/1_80_0/libs/range/doc/html/range/reference/utilities/combine.html"><code>boost::combine</code></a> example: </p>
<pre><code class="language-cpp">std::vector&lt;int&gt; va{1, 2, 3};
std::vectro&lt;float&gt; vb{0.5, 1, 1.5};
for(const auto&amp; [a, b]: boost::combine(va, vb)){
    ...
}
</code></pre>
<p>Each argument of combine must satisfy <a href="https://www.boost.org/doc/libs/1_80_0/libs/range/doc/html/range/concepts/single_pass_range.html">boost::SinglePassRange</a></p>
<h2 id="enumerating">Enumerating<a class="headerlink" href="#enumerating" title="Permanent link">&para;</a></h2>
<p>There is no function in standard library equivalent to the python enumerate. We can use a similar boost solution:</p>
<pre><code class="language-cpp">#include &lt;boost/range/adaptor/indexed.hpp&gt;

for(auto const&amp; el: &lt;range&gt; | boost::adaptors::indexed(0)){
    std::cout &lt;&lt; el.index() &lt;&lt; &quot;: &quot; &lt;&lt; el.value() &lt;&lt; std::endl;
}
</code></pre>
<p>However, inside the loop, we have to call the <code>index</code> and <code>value</code> functions, so it is probably easier to stick to the good old extra variable:</p>
<pre><code class="language-cpp">size_t i = 0;
for(auto const&amp; el: &lt;range&gt;) {
  std::cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; el &lt;&lt; std::endl;
  ++i;
}
</code></pre>
<h2 id="sorting">Sorting<a class="headerlink" href="#sorting" title="Permanent link">&para;</a></h2>
<p>There is no sorted view or something simmiler, so in order to sort a range, we need to:</p>
<ul>
<li>really sort the object in the range</li>
<li>create an adaptor/view from the range, and then sort the view</li>
</ul>
<p>There are two functions for sorting in the STL algorithm library:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/sort"><code>std::sort</code></a>: old<ul>
<li>supports parallelization directly by the policy param</li>
</ul>
</li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/sort"><code>std::ranges::sort</code></a>: new<ul>
<li>supports comparison using projections</li>
</ul>
</li>
</ul>
<p>There are three types of sorting:</p>
<ul>
<li>natural sorting using the <code>&lt;</code> operator of <code>T</code> : <code>std::sort(&lt;RANGE&lt;T&gt;&gt;)</code></li>
<li>sorting using a comparator: <code>std::sort(&lt;RANGE&gt;, &lt;COMPARATOR&gt;)</code>, where comparator is a fuction with parameters and return value analogous to the natural sorting operator.</li>
<li>sorting using projection (only availeble in <code>std::ranges::sort</code>): <code>std::ranges::sort(&lt;RANGE&gt;, &lt;STANDARD GENERIC COMPARATOR&gt;, &lt;PROJECTION&gt;</code></li>
</ul>
<h3 id="sorting-using-projection">Sorting using projection<a class="headerlink" href="#sorting-using-projection" title="Permanent link">&para;</a></h3>
<p>When we want to sort the objects by a single property different then natural sorting, the easiest way is to use projection. Example:</p>
<pre><code class="language-cpp">struct Data {
    int a;
    std::string b;
    ...
};

std::vector&lt;Data&gt; data = get_data();

std::sort(data, {}, &amp;Data::b);
</code></pre>
<p>The trick here is that we can only provide the member that we want to use for sorting, but the sorting logic (<code>first &lt; second</code>...) is handeled by a standard comparator (the second argument initialized with <code>{}</code>).</p>
<p>We can have even more complicated projections:</p>
<pre><code class="language-cpp">std::vector&lt;My_class&gt; objects = get_objects();
std::vector&lt;unsigned&gt; indexes = get_indexes(objects);
auto proj = [&amp;objects](std::size_t i) -&gt; const std::string&amp; { 
    return objects[i].get_name(); 
};
std::ranges::sort(indexes, {}, proj) // sort indexes using the property of objects
</code></pre>
<h2 id="transformation">Transformation<a class="headerlink" href="#transformation" title="Permanent link">&para;</a></h2>
<p>Transformation alg/views transforms an input range according to a callable. As with other operation, there are thre options:</p>
<ul>
<li>classical algorithm: <a href="https://en.cppreference.com/w/cpp/algorithm/transform"><code>std::transform</code></a> with a direct paralellization using the policy parameter</li>
<li>range algorithm: <a href="https://en.cppreference.com/w/cpp/algorithm/ranges/transform"><code>std::ranges::transform</code></a> with a support for projections</li>
<li>range view: <a href="https://en.cppreference.com/w/cpp/ranges/transform_view"><code>std::ranges::views::transform</code></a> - a lazy variant</li>
</ul>
<p>The algorithms (but not the view) also supports <strong>binary transformations</strong>, i.e., create an output range using two input ranges.</p>
<p>Transform view example:</p>
<pre><code class="language-c++">std::vector&lt;int&gt; in(3, 0); // [0, 0, 0]
auto ad = std::ranges::transform_view(in, [](const auto in){return in + 1;});
std::vector&lt;int&gt; out(ad.begin(), ad.end());
</code></pre>
<p>The transform <em>view</em>  can be only constructed from an object satisfying <a href="http://en.cppreference.com/w/cpp/ranges/input_range"><code>ranges::input_range</code></a>. If we want to use a general range (e.g., vector), we need to call the addapter, which has a same signature like the view constructor itself. The important thing here is that the adapter return type is not a <code>std::ranges::views::transform&lt;&lt;RANGE&gt;&gt;</code> but <code>std::ranges::views::transform&lt;std::ranges::ref_view&lt;RANGE&gt;&gt;&gt;</code> (<a href="https://en.cppreference.com/w/cpp/ranges/ref_view"><code>std::ranges::ref_view</code></a>). Supporting various collections is therefore possible only with teplates, but not with inheritance.</p>
<p><strong>Note that unlike in Java, it is not possible to use a member reference as a transformation function (e.g.: <code>&amp;MyClass::to_sting()</code>).</strong> We have to always use lambda functions, <code>std::bind</code> or similar to create the callable.</p>
<h2 id="aggregating-sum-product-etc">Aggregating (sum, product, etc.)<a class="headerlink" href="#aggregating-sum-product-etc" title="Permanent link">&para;</a></h2>
<p>These operations can be done using the <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate"><code>std::accumulate</code></a> algorithm. This algorithm is about to be replaced by the <code>std::ranges::fold</code> algorithm, but it is not yet implemented in Clang. Examples:</p>
<pre><code class="language-cpp">// default accumulation -&gt; sum
std::vector&lt;int&gt; vec{1, 2, 3, 4, 5};
int sum = std::accumulate(vec.begin(), vec.end(), 0);

// product
int product = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies&lt;int&gt;());
</code></pre>
<h2 id="implementing-a-custom-range">Implementing a custom range<a class="headerlink" href="#implementing-a-custom-range" title="Permanent link">&para;</a></h2>
<p>There are different requirements for different types of ranges. Moreover, there are different requirements for the <a href="https://en.cppreference.com/w/cpp/language/range-for">range-based for loop (for each)</a>, or the legacy STL algorithms. </p>
<p>Here we focus on requirements for ranges. Not however, that the range requirements are more strict than the requirements for the range-based for loop or the legacy STL algorithms. Therefore, the described approach should work for all three cases.</p>
<p>Usually, we proceed as follows:</p>
<ol>
<li>Choose the right range (Iterable) concept for your range from the <a href="https://en.cppreference.com/w/cpp/ranges">STL range concepts</a>.<ul>
<li>The most common is the <a href="https://en.cppreference.com/w/cpp/ranges/input_range"><code>std::ranges::input_range</code></a> concept.</li>
</ul>
</li>
<li>Implement the range concept for the range.<ul>
<li>Either, we can do it by using the interface of the undelying range we usein our class (i.e, we just forward the calls to the methods of <code>std::vector</code> or <code>std::unordered_map</code>) or</li>
<li>implement the interface from scratch. For that, we also need to implement the iterator class that fulfills the corresponding <a href="https://en.cppreference.com/w/cpp/iterator">iterator concept</a> (e.g., <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator"><code>std::input_iterator</code></a> for the <code>std::ranges::input_range</code>).</li>
</ul>
</li>
</ol>
<h3 id="implementing-an-input-range">Implementing an input range<a class="headerlink" href="#implementing-an-input-range" title="Permanent link">&para;</a></h3>
<p>The input range is the most common range type. The only requirement for the input range is that it has to have the <code>begin</code> and <code>end</code> methods that return the input iterator. Example:</p>
<pre><code class="language-cpp">class My_range {
    private:
        std::vector&lt;int&gt; data;
    public:
        My_range(std::vector&lt;int&gt; data): data(data) {}
        auto begin() {return data.begin();}
        auto end() {return data.end();}

        // usually, we also want a const version of the range
        auto begin() const {return data.begin();}
        auto end() const {return data.end();}
};
</code></pre>
<h2 id="boost-iterator-templates">Boost Iterator Templates<a class="headerlink" href="#boost-iterator-templates" title="Permanent link">&para;</a></h2>
<p>The <a href="https://www.boost.org/doc/libs/1_77_0/libs/iterator/doc/index.html">boost.iterator library</a> provides some templates to implement iteratores easily, typically using some existing iterators and modifying just a small part of it:</p>
<ul>
<li>for pointer to type (dereference) iterator, you can use <a href="https://www.boost.org/doc/libs/1_54_0/libs/iterator/doc/indirect_iterator.html">boost indirect iterator</a></li>
<li><a href="https://www.boost.org/doc/libs/1_80_0/libs/iterator/doc/zip_iterator.html">zip iterator</a> for Python like iteration over multiple collections</li>
<li>[transform iteratorather useful iterators are also included in <a href="https://www.boost.org/doc/libs/1_787_0/libs/iterator/doc/transform_iterator.html">the boost.iterator library</a> for using another iterator and just modify the access (<code>*</code>) opindex.html). including:<ul>
<li>zip iterator.</li>
<li><a href="https://live.boost.org/doc/libs/1_78_0/libs/iterator/doc/counting_iterator.html">counting_iterator</a> to create number sequence like Python range</li>
</ul>
</li>
<li><a href="https://livewww.boost.org/doc/libs/1_787_0/libs/iterator/doc/generattransform_iterator.html">gentransform iterator</a></li>
</ul>
<p>There are also two general (most powerfull) classes:</p>
<ul>
<li><a href="https://live.boost.org/doc/libs/1_78_0/libs/iterator/doc/iterator_adaptor.html">iterator adapter</a></li>
<li>iterator facade</li>
</ul>
<h2 id="resources">Resources<a class="headerlink" href="#resources" title="Permanent link">&para;</a></h2>
<ul>
<li>
<p><a href="https://internalpointers.com/post/writing-custom-iterators-modern-cpp">How to write a legacy iterator</a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/iterator/iter_t">iter_value_t</a></p>
</li>
</ul>
<h1 id="lambda-functions">Lambda Functions<a class="headerlink" href="#lambda-functions" title="Permanent link">&para;</a></h1>
<p>In c++ <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a> are defined as:</p>
<pre><code class="language-cpp">[&lt;capture&gt;](&lt;params&gt;) -&gt; &lt;return_type&gt; { &lt;code&gt; }
</code></pre>
<p>The rerurn type is optional, but sometimes required (see below). </p>
<p>Since C++23, the parantheses are optional if there are no functon parameters.</p>
<h2 id="captures">Captures<a class="headerlink" href="#captures" title="Permanent link">&para;</a></h2>
<p>Anything that we want to use from outside has to appear in capture. To prevent copying, we should capture by reference, using <code>&amp;</code> before the name of the variable.</p>
<pre><code class="language-cpp">[&amp;var_1] // capture by reference
[var_1] // capture by value
[&amp;] // default capture by reference
</code></pre>
<p>For the detailed explanation of the captures, see <a href="https://en.cppreference.com/w/cpp/language/lambda#Lambda_capture">cppreference</a>.</p>
<h2 id="return-type">Return type<a class="headerlink" href="#return-type" title="Permanent link">&para;</a></h2>
<p>The return type of lambda functions can be set only using the trailing return type syntax (<code>-&gt; &lt;RETURN TYPE&gt;</code> after the function params). The return type can be omited. Note however, that <strong>the default return type is <code>auto</code></strong>, so in case we want to return by reference, we need to add at least <code>-&gt; auto</code>, or even a more specific return type.</p>
<h2 id="specifiers">Specifiers<a class="headerlink" href="#specifiers" title="Permanent link">&para;</a></h2>
<p>Lambda functions can have special specifiers:</p>
<ul>
<li><code>mutable</code>: lambda can modify function parameters capture by copy</li>
</ul>
<h1 id="exceptions">Exceptions<a class="headerlink" href="#exceptions" title="Permanent link">&para;</a></h1>
<p>In C++, exceptions works simillarly as in other languages. </p>
<p>Standard runtime error can be thrown using the <a href="https://en.cppreference.com/w/cpp/error/runtime_error"><code>std::runtime_error</code></a> class:</p>
<pre><code class="language-cpp">throw std::runtime_error(&quot;message&quot;);
</code></pre>
<p>Always catch exception by reference! </p>
<p>Note that unlike in Java or Python, there is no default exception handler in C++. Therefore, if an exception is not caught and, in conclusion, the program is terminated, there is no useful information about the exception in the standard output. Instead, we only receive the exit code. For this reason, it is a good practice to catch all exceptions in the main function and print the error message. Example:</p>
<pre><code class="language-cpp">int main() {
    try {
        &lt;the code of the whole program here&gt;
    } catch(...) {
        const std::exception_ptr&amp; eptr = std::current_exception();
        if (!eptr) {
            throw std::bad_exception();
        }

        /*char* message;*/
        std::string message;
        try {
            std::rethrow_exception(eptr);
        }
        catch (const std::exception&amp; e) {
            message = e.what();
        }
        catch (const std::string&amp; e) {
            message = e;
        }
        catch (const char* e) {
            message = e;
        }
        catch(const GRBException&amp; ex) {
            message = fmt::format(&quot;{}: {}&quot;, ex.getErrorCode(), ex.getMessage());
        }
        catch (...) {
            message = &quot;Unknown error&quot;;
        }

        spdlog::error(message);
        return message;
    }
}
</code></pre>
<h2 id="rethrowing-exceptions">Rethrowing Exceptions<a class="headerlink" href="#rethrowing-exceptions" title="Permanent link">&para;</a></h2>
<p>We can rethrow an exception like this:</p>
<pre><code class="language-cpp">catch(const std::exception&amp; ex){
    // do ssomething
    ...
    throw;
}
</code></pre>
<p>Note that <strong>in parallel regions, the exception have to be caught before the end of the parallel region</strong>, otherwise the thread is killed.</p>
<h2 id="how-to-catch-any-exception">How to Catch Any Exception<a class="headerlink" href="#how-to-catch-any-exception" title="Permanent link">&para;</a></h2>
<p>In C++, we can catch any exception with:</p>
<pre><code class="language-cpp">catch (...) {

}
</code></pre>
<p>However, this way, we cannot access the exception object. As there is no base class for exceptions in C++, there is no way to catch all kind of exception objects in C++.</p>
<h2 id="noexcept-specification"><code>noexcept</code> specification<a class="headerlink" href="#noexcept-specification" title="Permanent link">&para;</a></h2>
<p>A lot of templates in C++ requires functions to be <a href="https://en.cppreference.com/w/cpp/language/noexcept_spec"><code>noexcept</code></a> which is usually checked by a type trait <a href="https://en.cppreference.com/w/cpp/types/is_invocable"><code>std::is_nothrow_invocable</code></a>. We can easily modify our function to satisfy this by adding a <code>noexcept</code> to the function declariaton.</p>
<p>There are no requirements for a <code>noexcept</code> function. It can call functions without noexcept or even throw exceptions itself. The only difference it that uncought exceptions from a <code>noexcept</code> function are not passed to the caller. Instead the program is terminated by calling <a href="https://en.cppreference.com/w/cpp/error/terminate"><code>std::terminate</code></a>, which otherwise happens only if the <code>main</code> function throws.</p>
<p>By default, only constructors, destructors, and copy/move operations are noexcept.</p>
<h2 id="stack-traces">Stack traces<a class="headerlink" href="#stack-traces" title="Permanent link">&para;</a></h2>
<p>Unlike most other languages, C++ does not print stack trace on program termination. The only way to get a stack trace for all exceptions is to set up a custom terminate handler an inside it, print the stack trace. </p>
<p><strong>However, as of 2023, all the stack trace printing/generating libraries requires platform dependent configuration and fails to work in some platforms or configurations.</strong></p>
<p>Example:</p>
<pre><code class="language-cpp"> void terminate_handler_with_stacktrace() {
    try {
        &lt;stack trace generation here&gt;;
    } catch (...) {}
    std::abort();
}

std::set_terminate(&amp;terminate_handler_with_stacktrace);
</code></pre>
<p>To create the stacktrace, we can use one of the stacktrace libraries:</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/header/stacktrace">stacktrace</a> header from the standard library if the compiler supports it (C++ 23)<ul>
<li>as of 2024-04, only MSVC supports this functionality</li>
</ul>
</li>
<li><a href="https://github.com/jeremy-rifkin/cpptrace">cpptrace</a></li>
<li><a href="https://github.com/boostorg/stacktrace/">boost stacktrace</a></li>
</ul>
<h1 id="logging">Logging<a class="headerlink" href="#logging" title="Permanent link">&para;</a></h1>
<p>There is no build in logging in C++. However, there are some libraries that can be used for logging. In this section we will present logging using the <a href="https://github.com/gabime/spdlog">spdlog</a> library.</p>
<p>We can log using the <code>spdlog::&lt;LEVEL&gt;</code> functions:</p>
<pre><code class="language-cpp">spdlog::info(&quot;Hello, {}!&quot;, &quot;World&quot;);
</code></pre>
<p>By default, the log is written to console. In order to write also to a file, we need to create loggers manually and set the list of sinks as a default logger:</p>
<pre><code class="language-cpp">const auto console_sink = std::make_shared&lt;spdlog::sinks::stdout_sink_st&gt;();
console_sink-&gt;set_level(spdlog::level::info); // log level for console sink

auto file_sink = std::make_shared&lt;spdlog::sinks::basic_file_sink_st&gt;(&lt;log filepath&gt;, true);

std::initializer_list&lt;spdlog::sink_ptr&gt; sink_list{console_sink, file_sink};
const auto logger = std::make_shared&lt;spdlog::logger&gt;(&lt;LOGGER NAME&gt;, sink_list);
logger-&gt;set_level(spdlog::level::debug); //log level for the whole logger

spdlog::set_default_logger(logger);
</code></pre>
<p>To save performance in case of an intensive logging, we can set an extended flushing period:</p>
<pre><code class="language-cpp">spdlog::flush_every(std::chrono::seconds(5));
</code></pre>
<h2 id="levels">Levels<a class="headerlink" href="#levels" title="Permanent link">&para;</a></h2>
<p>The log levels are defined in the <a href="https://github.com/gabime/spdlog/blob/v1.x/include/spdlog/common.h#L231"><code>spdlog::level::level_enum</code></a>. The levels are:</p>
<ul>
<li><code>trace</code></li>
<li><code>debug</code></li>
<li><code>info</code></li>
<li><code>warn</code></li>
<li><code>error</code></li>
<li><code>critical</code></li>
</ul>
<h2 id="colors">Colors<a class="headerlink" href="#colors" title="Permanent link">&para;</a></h2>
<p>By default, the logger uses colors for different log levels. However, this capability is lost when:</p>
<ul>
<li>using custom sinks or</li>
<li>using custom formatters</li>
</ul>
<p>To keep the colors, we need to a) use the color sink and b) explicitly set the usage of the color in the formatter:</p>
<pre><code class="language-cpp">auto console_sink = std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;();

auto logger = std::make_shared&lt;spdlog::logger&gt;(&quot;console&quot;, console_sink);
logger-&gt;set_pattern(&quot;[%^%l%$] %v&quot;);
</code></pre>
<p>Here <code>%^</code> and <code>%$</code> are the color start and end markers.</p>
<h1 id="type-aliases">Type Aliases<a class="headerlink" href="#type-aliases" title="Permanent link">&para;</a></h1>
<p>Type aliases are short names bound to some other types. We can introduce it either with <code>typedef</code> or with <code>using</code> keyword. Examples (equvalent):</p>
<pre><code class="language-cpp">typedef int number;
using number = int;

typedef void func(int,int);
using func = void(int, int)
</code></pre>
<p>The <code>using</code>new syntax is more readable, as the alias is at the begining of the expression. But why to use type aliases? Two strong motivations can be:</p>
<ul>
<li><strong>iImprove the readebility</strong>: When we work with a type with a very long declaration, it is wise to use an alias. We can partialy solve this issue by using auto, but that is not a complete solution</li>
<li><strong>Make the refactoring easier</strong>: When w work with aliases, it is easy to change the type we work with, just by redefining the alias. </li>
</ul>
<p>Note that <strong>type aliases cannot have the same name as variables in the same scope</strong>. So it is usually safer to name type aliases with this in mind, i.e., <code>using id_type = ..</code> insted of <code>using id = ..</code></p>
<h2 id="template-aliasis">Template Aliasis<a class="headerlink" href="#template-aliasis" title="Permanent link">&para;</a></h2>
<p>We can also create template aliases as follows:</p>
<pre><code class="language-cpp">template&lt;class A, typename B&gt; 
class some_template{ ... };

template&lt;class T&gt;
using my_template_alias = some_template&lt;T, int&gt;; 
</code></pre>
<h2 id="aliases-inside-classes">Aliases inside classes<a class="headerlink" href="#aliases-inside-classes" title="Permanent link">&para;</a></h2>
<p>The type alias can also be  placed inside a class. From outside the class, it can be accessed as <code>&lt;CLASS NAME&gt;::&lt;ALIAS NAME&gt;</code>:</p>
<pre><code class="language-cpp">class My_class{
public:
    using number = unsigned long long

    number n = 0;
}

My_class::number number = 5;
</code></pre>
<h1 id="constant-expressions">Constant Expressions<a class="headerlink" href="#constant-expressions" title="Permanent link">&para;</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/constant_expression">cppreference</a>.</p>
<p>A constant expression is an expression that can be evaluated at compile time. The result of constant expression can be used in static context, i.e., it can be:</p>
<ul>
<li>assigned to a <code>constexpr</code> variable,</li>
<li>tested for true using <code>static_assert</code></li>
</ul>
<p>Unfortunatelly, <a href="https://stackoverflow.com/a/47538175/1827955">there is no universal way how to determine if an expression is a constant expression</a>.</p>
<h2 id="compile-time-branching">Compile Time Branching<a class="headerlink" href="#compile-time-branching" title="Permanent link">&para;</a></h2>
<p>For compile time branching, we can use the <code>if constexpr</code>:</p>
<pre><code class="language-cpp">template&lt;class T, class C&gt;
class Object{
public:
    bool process(T value, C config){
        if constexpr (std::is_same_v&lt;T, std::string&gt;){
            return process_string(value, config);
        } 
        else {
            return process_value(value, config);
        }
    }
};
</code></pre>
<p>Note that here, the <code>if constexpr</code> requires the corresponding <code>else</code> branch. Otherwise, the code cannot be discarded during the compilation. Example:</p>
<pre><code class="language-cpp">template&lt;class T, class C&gt;
class Object{
public:
    bool process(T value, C config){
        if constexpr (std::is_same_v&lt;T, std::string&gt;){
            return process_string(value, config);
        } 

        return process_value(value, config); // this compiles even if T is std::string
    }
};
</code></pre>
<h1 id="regular-expressions">Regular expressions<a class="headerlink" href="#regular-expressions" title="Permanent link">&para;</a></h1>
<p>The regex patern is stored in a <code>std::regex</code> object:</p>
<pre><code class="language-cpp">const std::regex regex{R&quot;regex(Plan (\d+))regex&quot;};
</code></pre>
<p>Note that <strong>we use the raw string</strong> so we do not have to escape the pattern. Also, note that <code>std::regex</code> cannot be <code>constexpr</code></p>
<h2 id="matching-the-result">Matching the result<a class="headerlink" href="#matching-the-result" title="Permanent link">&para;</a></h2>
<p>We use the <a href="https://en.cppreference.com/w/cpp/regex/regex_search"><code>std::regex_search</code></a> to search for the occurence of the pattern in a string. The result is stored in a <code>std::smatch</code> object which contains the whole match on the 0th index and then the macthed groups on subsequent indices.
A typical operation:</p>
<pre><code class="language-cpp">std::smatch matches;
const auto found = std::regex_search(string, matches, regex);
if(found){
    auto plan_id = matches[1].str(); // finds the first group
}
</code></pre>
<p><strong>Note that <code>matches[0]</code> is not the first matched group, but the whole match.</strong> </p>
<h1 id="namespaces">Namespaces<a class="headerlink" href="#namespaces" title="Permanent link">&para;</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/namespace">cppreference</a></p>
<p>Namespace provides duplicit-name protection, it is a similar concept to Java packages. Contrary to java packages and modules, the C++ namespaces are unrelated to the directory structure.</p>
<pre><code class="language-cpp">namespace my_namespace {
    ...
}
</code></pre>
<p>The namespaces are used in both declaration and definition (both in header and source files). </p>
<p>The inner namespace has access to outer namespaces. For using some namespace inside our namespace without full qualification, we can write:</p>
<pre><code class="language-cpp">using namespace &lt;NAMESPACE NAME&gt;
</code></pre>
<h2 id="anonymous-namespaces">Anonymous namespaces<a class="headerlink" href="#anonymous-namespaces" title="Permanent link">&para;</a></h2>
<p>Anonymous namespaces are declared as:</p>
<pre><code class="language-cpp">namespace {
    ...
}
</code></pre>
<p>Each anonnymous namespaces has a different and unknown ID. Therefore, the content of the annonymous namespace cannot be accessed from outside the namespace, with exception of the file where the namespace is declared which has an implicit access to it.</p>
<h2 id="namespace-aliases">Namespace aliases<a class="headerlink" href="#namespace-aliases" title="Permanent link">&para;</a></h2>
<p>We can create a <a href="https://en.cppreference.com/w/cpp/language/namespace_alias">namespace alias</a> using the <code>namespace</code> keyword to short the nested namespace names. Typicall example:</p>
<pre><code class="language-cpp">namespace fs = std::filesystem;
</code></pre>
<h1 id="decltype-determining-type-from-expressions"><code>decltype</code>: Determining Type from Expressions<a class="headerlink" href="#decltype-determining-type-from-expressions" title="Permanent link">&para;</a></h1>
<p>Sometimes, it is usefull to declare a type from expression, instead of do it manualy. Using  <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a> specifier, we can get the resulting type of an expression as if it was evaluated. Examples:</p>
<pre><code class="language-cpp">struct A { double x; };
const A* a;

decltype(a-&gt;x) // evaluates to double

decltype(std::accumulate(a, [](double sum, double val){return sum + val;})) // evalutes to double
</code></pre>
<p>We can use the <code>decltype</code> in any context where type is required. Examples:</p>
<pre><code class="language-cpp">int i = 1
decltype(i) j = 3

std::vector&lt;decltype(j)&gt; numbers;
</code></pre>
<h2 id="the-value-category-of-decltype">The Value Category of <code>decltype</code><a class="headerlink" href="#the-value-category-of-decltype" title="Permanent link">&para;</a></h2>
<p>The value category of <code>decltype</code> is resolved depending on the value category of an expression inside it:</p>
<ul>
<li><code>deltype(&lt;XVALUE&gt;)</code> -&gt; <code>T&amp;&amp;</code></li>
<li><code>deltype(&lt;LVALUE&gt;)</code> -&gt; <code>T&amp;</code></li>
<li><code>deltype(&lt;RVALUE&gt;)</code> -&gt; <code>T</code></li>
</ul>
<p>The rvalue conversion can lead to unexpected results, in context, where the value type matters:</p>
<pre><code class="language-cpp">static_assert(std::is_same_v&lt;decltype(0), decltype(std::identity()(0))&gt;); // error
</code></pre>
<p>The above expressions fails because:</p>
<ul>
<li><code>decltype(0)</code>, <code>0</code> is an rvalue <code>-&gt;</code> the <code>decltype</code> result is <code>int</code></li>
<li><code>decltype(std::identity()(0))</code> result of <a href="https://en.cppreference.com/w/cpp/utility/functional/identity"><code>std::identity()</code></a> is an xvalue <code>-&gt;</code> the <code>decltype</code> result is <code>int&amp;&amp;</code>. Determining Type from Expressions
Sometimes, it is usefull to declare a type from expression, instead of do it manualy. Using  <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a> specifier, we can get the resulting type of an expression as if it was evaluated. Examples:</li>
</ul>
<pre><code class="language-cpp">struct A { double x; };
const A* a;

decltype(a-&gt;x) // evaluates to double

decltype(std::accumulate(a, [](double sum, double val){return sum + val;})) // evalutes to double
</code></pre>
<p>We can use the <code>decltype</code> in any context where type is required. Examples:</p>
<pre><code class="language-cpp">int i = 1
decltype(i) j = 3

std::vector&lt;decltype(j)&gt; numbers;
</code></pre>
<h3 id="determining-the-return-value-type-of-a-function">Determining the Return Value Type of a Function<a class="headerlink" href="#determining-the-return-value-type-of-a-function" title="Permanent link">&para;</a></h3>
<p>As we can see above, we can use <code>decltype</code> to determine the return value type. But also, there is a <em>type trait</em> for that: <a href="https://en.cppreference.com/w/cpp/types/result_of"><code>std::invoke_result_t</code></a> (formerly <code>std::result_of</code>). The <code>std::invoke_result_t</code> should vbe equal to <code>decltype</code> when aplied to return type, with the following limitations:</p>
<h2 id="-we-cannot-use-abstract-classes-as-arguments-of-stdinvoke_result_t-while-we-can-use-them-inside-decltype-using-stddeclval-see-below">- we cannot use abstract classes as arguments of <code>std::invoke_result_t</code>, while we can use them inside <code>decltype</code> (using <code>std::declval</code>, see below).<a class="headerlink" href="#-we-cannot-use-abstract-classes-as-arguments-of-stdinvoke_result_t-while-we-can-use-them-inside-decltype-using-stddeclval-see-below" title="Permanent link">&para;</a></h2>
<h3 id="construct-object-inside-decltype-with-stddeclval">Construct object inside <code>decltype</code> with <code>std::declval</code><a class="headerlink" href="#construct-object-inside-decltype-with-stddeclval" title="Permanent link">&para;</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/utility/declval"><code>std::declval</code></a> is a usefull function designed to be used only in static contexts, inside <code>decltype</code>. It enables using member functions inside decltype without using constructors.  Without <code>std::declval</code>, some type expressions are hard or even impossible to costruct. Example:</p>
<pre><code class="language-cpp">class Complex_class{
    Complex_class(int a, bool b, ...)
    ...

    int compute()
}

// without declval
decltype&lt;Complex_class(1, false, ...).compute()&gt; 

// using declval
decltype(std::declval&lt;Complex_class&gt;().compute())
</code></pre>
<h3 id="decltype-and-overloading"><code>decltype</code> and Overloading<a class="headerlink" href="#decltype-and-overloading" title="Permanent link">&para;</a></h3>
<p>in static context, there is no overloading, the vtable is not available. Therefore, we have to hint the compiler which specific overloaded function we want to evaluate. This also applies to const vs non const overloading. The following example shows how to get the const iterator type of a vector:</p>
<pre><code class="language-cpp">std::vector&lt;anything&gt; vec

// non const iter
decltype(vec.begin())

// const iter
decltype&lt;std::declval&lt;const decltype(vec)&gt;().begin()&gt;
</code></pre>
<p>Another example shows how to use the const overload inside <code>std::bind</code>:</p>
<pre><code class="language-cpp">decltype(std::bind(static_cast&lt;const ActionData&lt;N&gt;&amp;(std::vector&lt;ActionData&lt;N&gt;&gt;::*)(size_t) const&gt;(&amp;std::vector&lt;ActionData&lt;N&gt;&gt;::operator[]), action_data)),
</code></pre>
<p>Above, we used static cast for choosing the const version of the vector array operator. Instead, we can use explicit template argument for <code>std::bind</code>:</p>
<pre><code class="language-cpp">decltype(std::bind&lt;const ActionData&lt;N&gt;&amp; (std::vector&lt;ActionData&lt;N&gt;&gt;::*)(size_t) const&gt;(&amp;std::vector&lt;ActionData&lt;N&gt;&gt;::operator[], action_data)),
</code></pre>
<h1 id="parallelization">Parallelization<a class="headerlink" href="#parallelization" title="Permanent link">&para;</a></h1>
<p>While there wa no support of parallelization i earlier versions of C++ , now there are many tools.</p>
<h2 id="standard-threads">Standard Threads<a class="headerlink" href="#standard-threads" title="Permanent link">&para;</a></h2>
<h2 id="for-each-with-parallel-execution-policy">For-each with Parallel Execution Policy<a class="headerlink" href="#for-each-with-parallel-execution-policy" title="Permanent link">&para;</a></h2>
<p>The function <a href="https://en.cppreference.com/w/cpp/algorithm/for_each"><code>std::for_each</code></a> can be run with a parallel execution policy to process the loop in parallel.</p>
<h2 id="async-tasks">Async tasks<a class="headerlink" href="#async-tasks" title="Permanent link">&para;</a></h2>
<p>Tasks for asznchronous execution, like file downloads, db queries, etc. The main function is <a href="https://en.cppreference.com/w/cpp/thread/async"><code>std::async</code></a>.</p>
<h2 id="open-mp">Open-MP<a class="headerlink" href="#open-mp" title="Permanent link">&para;</a></h2>
<p>In MSVC, the Open MP library is automatically included and linked. In GCC, we need to find the libs in <code>CmakeLists.txt</code>:</p>
<pre><code class="language-cmake">find_package(OpenMP REQUIRED)
</code></pre>
<h1 id="standard-templates-for-callables">Standard Templates for Callables<a class="headerlink" href="#standard-templates-for-callables" title="Permanent link">&para;</a></h1>
<h2 id="using-stdinvoke-to-call-the-member-function">Using std::invoke to call the member function<a class="headerlink" href="#using-stdinvoke-to-call-the-member-function" title="Permanent link">&para;</a></h2>
<p>using <a href="https://en.cppreference.com/w/cpp/utility/functional/invoke"><code>std::invoke</code></a>, the cal syntax <code>bool b = (inst.*ptr)()</code> can be replaced with longer but more straighforward call:</p>
<pre><code class="language-cpp">bool b = std::invoke(ptr, inst, 2) 
</code></pre>
<h2 id="using-stdmem_fn-to-store-a-pointer-to-member-function-in-a-callable">Using std::mem_fn to Store a Pointer to Member Function in a Callable<a class="headerlink" href="#using-stdmem_fn-to-store-a-pointer-to-member-function-in-a-callable" title="Permanent link">&para;</a></h2>
<p>With <a href="https://en.cppreference.com/w/cpp/utility/functional/mem_fn"><code>std::mem_fn</code></a>, we can store the pointer to a member function in a callable object. Later, we can call the object without the pointer to the member function. Example:</p>
<pre><code class="language-c++">auto mem_ptr = std::mem_fn(&amp;My_class::my_method)
bool b = mem_ptr(inst, 2)
</code></pre>
<h2 id="using-a-pointer-to-member-function-as-a-functor">Using a Pointer to Member Function as a Functor<a class="headerlink" href="#using-a-pointer-to-member-function-as-a-functor" title="Permanent link">&para;</a></h2>
<p>A normal function can be usually send instead of functor, as it can be invoked in the same way. However, in case of  member function, we usually need to somehow bind the function pointer to the instance. We can use the <a href="https://en.cppreference.com/w/cpp/utility/functional/bind"><code>std::bind</code></a> function exactly for that:</p>
<pre><code class="language-cpp">auto functor = std::bind(&amp;My_class::my_method, inst);
bool b = functor(2)
</code></pre>
<p>Advanteges:</p>
<ul>
<li>we do not need an access to instance in the context from which we call the member function</li>
<li>we do not have to remember the complex syntax of a pointer to a member function declaration</li>
<li>we receive a callable object, which usage is even simpler than using <code>std::invoke</code></li>
</ul>
<p>Note that in case we want to bind only some parameters, we need to supply placeholders for the remaining parameters (<code>std::placeholders</code>).</p>
<h2 id="using-lambdas-instead-of-stdbind">Using Lambdas Instead of std::bind<a class="headerlink" href="#using-lambdas-instead-of-stdbind" title="Permanent link">&para;</a></h2>
<p>For more readable code and better compile error messages, it is usefull to replace <code>std::bind</code> callls with labda functions. The above example can be rewritten as:</p>
<pre><code class="language-cpp">auto functor = [inst](int num){return inst.my_method(num););
bool b = functor(2)
</code></pre>
<h2 id="store-the-result-of-stdbind">Store the Result of std::bind<a class="headerlink" href="#store-the-result-of-stdbind" title="Permanent link">&para;</a></h2>
<p>Sometimes, we need to know the return type of the <code>std::bind</code>. In many context, we need to provide the type instead of using <code>auto</code>. But luckily, there is a type exactly for that: <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a>. Example:</p>
<pre><code class="language-cpp">std::function&lt;bool(int)&gt; functor = std::bind(&amp;My_class::my_method, inst);
bool b = functor(2)
</code></pre>
<p>A lambda can also be stored to <code>std::function</code>. But be carefull to add an explicit return type to it, if it returns by a reference. Example:</p>
<pre><code class="language-cpp">My_class{
public:
    int my_member
}

My_class inst;

std::function f = [inst](){return &amp;inst.my_member; } // wrong, reference to a temporary due to return type deduction
std::function f = [inst]() -&gt; const int&amp; {return &amp;inst.my_member; } // correct

</code></pre>
<p><a href="https://isocpp.org/wiki/faq/pointers-to-members">More detailed information about pointers to member functions</a></p>
<h2 id="stdmem_fn-and-data-members">std::mem_fn and Data Members<a class="headerlink" href="#stdmem_fn-and-data-members" title="Permanent link">&para;</a></h2>
<p>Data member pointers can be aslo stored as <a href="https://en.cppreference.com/w/cpp/utility/functional/mem_fn"><code>std::mem_fn</code></a>. A call to this object with an instance as the only argument then return the data member value.</p>
<p>The plain syntax is <code>&lt;type&gt; &lt;class name&gt;.*&lt;pointer name&gt; = &lt;class name&gt;.&lt;member name&gt;</code>, and the pointer is then accessed as <code>&lt;instance&gt;.*&lt;pointer name&gt;</code>. Example:</p>
<pre><code class="language-cpp">int Car::*pSpeed = &amp;Car::speed;
c1.*pSpeed = 2;
</code></pre>
<p>Usefull STL functions</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/for_each"><code>std::for_each</code></a>: iterates over iterable objects and call a callable for each iteration</li>
<li><a href="https://en.cppreference.com/w/cpp/utility/functional/bind"><code>std::bind</code></a>: Binds a function call to a variable that can be called<ul>
<li>some parameters of the function can be fixed in the variable, while others can be provided for each call</li>
<li>each reference parameter has to be wrapped as a <code>reference_wrapper</code></li>
</ul>
</li>
<li><a href="https://en.cppreference.com/w/cpp/utility/functional/mem_fn"><code>std:mem_fn</code></a>: Creates a variable that represents a callable that calls member function</li>
</ul>
<h2 id="stdfunction">std::function<a class="headerlink" href="#stdfunction" title="Permanent link">&para;</a></h2>
<p>The <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a> template can hold any callable. It can be initialized from:</p>
<ul>
<li>function pointer/reference, </li>
<li>member function pointer/reference, </li>
<li>lambda function </li>
<li>functor</li>
</ul>
<p>It can be easily passed to functions, used as template parameter, etc. The template parameters for <code>std::function</code> has the form of <code>std::function&lt;&lt;RETURN TYPE&gt;(&lt;ARGUMENTS&gt;)&gt;</code>. Example:</p>
<pre><code class="language-cpp">auto lambda = [](std::size_t i) -&gt; My_class { return My_class(i); };

std::function&lt;My_class(std::size_t)&gt; f{lambda}
</code></pre>
<h3 id="stdfunction-and-overloading">std::function and overloading<a class="headerlink" href="#stdfunction-and-overloading" title="Permanent link">&para;</a></h3>
<p>one of the traps when using <code>std::function</code> is the ambiguity when using an overloade function:</p>
<pre><code class="language-c++">int add(int, int);
double add(double, double);

std::function&lt;int(int, int)&gt; func = add; // fails due to ambiguity.
</code></pre>
<p>The solution is to cant the function to its type first and then assign it to the template:</p>
<pre><code>std::function&lt;int(int, int)&gt; func = static_cast&lt;int(*)(int, int)&gt;add;
</code></pre>
<h1 id="preprocessor-directives">Preprocessor Directives<a class="headerlink" href="#preprocessor-directives" title="Permanent link">&para;</a></h1>
<p>The C language has a <a href="https://en.wikipedia.org/wiki/C_preprocessor">preprocessor</a> that uses a specific syntax to modify the code before the compilation. This preprocessor is also used in C++. The most used tasks are:</p>
<ul>
<li>including files (<code>#include</code>): equivalent to Java or Python <code>import</code> statement</li>
<li>conditional compilation based on OS, compiler, or other conditions</li>
</ul>
<p>Also, preprocessor had some other purposes, now replaced by other tools:</p>
<ul>
<li>defining constants (<code>#define</code>): replaced by <code>const</code> and <code>constexpr</code><ul>
<li>A simple constant can be defined as: <code>#define PI 3.14159</code>. The variable can be used in the code as <code>PI</code>.</li>
</ul>
</li>
<li>metaprogramming: replaced by templates</li>
</ul>
<h2 id="include">Include<a class="headerlink" href="#include" title="Permanent link">&para;</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/preprocessor/include">cppreference</a></p>
<p>There are two types of include directives. For both types, the behavior is implementation dependent. However, the most common behavior is:</p>
<ul>
<li><code>#include &lt;file&gt;</code>: the file is searched in the system directories</li>
<li><code>#include "file"</code>: the file is searched relative to the current file</li>
</ul>
<h3 id="conditional-include">Conditional include<a class="headerlink" href="#conditional-include" title="Permanent link">&para;</a></h3>
<p>Sometimes, we need a conditional include based on what is available in the system. We can use two mechanisms:</p>
<ul>
<li><code>__has_include(&lt;file&gt;)</code>: Basically, we test the header availability during compilation:
    <code>cpp
    #if __has_include(&lt;format&gt;)
        #include &lt;format&gt;
        using namespace format = std::format;
    #else
        #include &lt;fmt/format.h&gt;
        using namespace format = fmt;
    #endif</code><ul>
<li>only available since C++17</li>
</ul>
</li>
<li>predefined compiler variable: We define some variable during project configuration and then use it in the preprocessor control structure:
    <code>cmake
    set(USE_FMT ON)</code>
    <code>cpp
    #if USE_FMT
        #include &lt;fmt/format.h&gt;
        using namespace format = fmt;
    #else
        #include &lt;format&gt;
        using namespace format = std::format;
    #endif</code><ul>
<li><strong>never use this for public headers</strong>, it is not portable as each client project now has to set the variable in the cmake configuration</li>
</ul>
</li>
</ul>
<h2 id="control-structures_1">Control structures<a class="headerlink" href="#control-structures_1" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">#ifdef &lt;MACRO&gt;
    ...
#elif &lt;MACRO&gt;
    ...
#else
    ...
#endif
</code></pre>
<p>Instead of <code>#ifdef &lt;MACRO&gt;</code>, we can use <code>#if defined(&lt;MACRO&gt;)</code>. In this case, we can use multiple conditions in one <code>#if</code> directive:</p>
<pre><code class="language-cpp">#if defined(MACRO_1) &amp;&amp; defined(MACRO_2)
    ...
#endif
</code></pre>
<h2 id="predefined-macros-for-detecting-compiler-os-etc">Predefined macros for detecting compiler, OS, etc.<a class="headerlink" href="#predefined-macros-for-detecting-compiler-os-etc" title="Permanent link">&para;</a></h2>
<p>To detect the <strong>Operating system</strong>, use:</p>
<ul>
<li><code>#ifdef _WIN32</code> for Windows</li>
<li><code>#ifdef __linux__</code> for Linux</li>
<li><code>#ifdef unix</code> for Unix-like systems (but not MacOS)</li>
<li><code>#ifdef __APPLE__</code> for MacOS</li>
</ul>
<h2 id="debugging-preprocessor-directives">Debugging preprocessor directives<a class="headerlink" href="#debugging-preprocessor-directives" title="Permanent link">&para;</a></h2>
<p>Sometimes, it may be usefull to print the value of a macro, or show which branch of the <code>#if</code> directive was taken. This can be done using the <code>#pragma message</code> directive:</p>
<pre><code class="language-cpp">#ifdef MACRO
    #pragma message(&quot;MACRO is defined&quot;)
#else
    #pragma message(&quot;MACRO is not defined&quot;)
#endif
</code></pre>
<h1 id="resources_1">Resources<a class="headerlink" href="#resources_1" title="Permanent link">&para;</a></h1>
<p>In C++, there is no facility for resource management like in Java or Python. Instead, resources have to be loaded like standard files. </p>
<p>Moreover, there is no built-in way how to determine the localtion of the running executable so that we can load the resources from the same directory. Typically, this has to be implemented for each platform separately:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;filesystem&gt;
#ifdef _WIN32
#include &lt;windows.h&gt;
#else
#include &lt;unistd.h&gt;
#endif

std::string get_executable_path() {
    char buffer[1024];
#ifdef _WIN32
    GetModuleFileNameA(NULL, buffer, sizeof(buffer));
#else
    ssize_t count = readlink(&quot;/proc/self/exe&quot;, buffer, sizeof(buffer));
    if (count == -1) throw std::runtime_error(&quot;Failed to get executable path&quot;);
    buffer[count] = '\0';
#endif
    return std::filesystem::path(buffer).parent_path().string();
}
</code></pre>
<h1 id="testing-with-google-test">Testing with Google Test<a class="headerlink" href="#testing-with-google-test" title="Permanent link">&para;</a></h1>
<h2 id="private-method-testing">Private method testing<a class="headerlink" href="#private-method-testing" title="Permanent link">&para;</a></h2>
<p>The testing of private method is not easy with Google Test, but that is common also for other tets frameworks or even computer languages (see the common manual). Some solutions are described in <a href="https://stackoverflow.com/questions/47354280/what-is-the-best-way-of-testing-private-methods-with-googletest">this SO question</a>.</p>
<p>Usually, the easiest solution is to aplly some naming/namespace convention and make the function accessible.</p>
<p>For free functions:</p>
<pre><code class="language-cpp">namespace internal {
    void private_function(){
        ...
    }
}
</code></pre>
<p>For member functions:</p>
<pre><code class="language-cpp">class MyClass{
public:
    void _private_function();
</code></pre>
<h1 id="memory-alignment">Memory Alignment<a class="headerlink" href="#memory-alignment" title="Permanent link">&para;</a></h1>
<p><a href="https://c-faq.com/struct/align.esr.html">Allignment FAQ</a></p>
<p><a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Wikipedia</a></p>
<p><a href="https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">SO question</a></p>
<p>In most cases, a sane programmer does not have to worry about memory optimization beyond choosing the right data types. However, in high-performance applications, where millions of objects are processed, even some details regarding the memory layout can have a significant impact on the performance. Therefore, we introduce some terminology and tools for memory optimization.</p>
<p>To make the memory access faster, the compiler aligns the data in the memory so that the memory can be read by the chunks natural for the architecture which are typically multiple of bytes. This affects both how the data structure members are stored (<em>padding</em>) and how the data structure itself is stored (<em>alignment</em>).</p>
<p>First, let's look at how much a data structure takes in memory. The data structure memory usage consists of:</p>
<ul>
<li>the size of its members, including base classes</li>
<li>the size of the <em>padding</em> between the members</li>
<li>if the strucrure use virtual methods, the size of the vtable</li>
</ul>
<p>Apart of the above, a structure itself may take even more memory due to the <em>alignment</em>.</p>
<p>Finally, there are strategies how to optimize the structure size called <em>packing</em>. See the <a href="http://www.catb.org/esr/structure-packing/">packing section</a> on the Eric S. Raymond's website for more details.</p>
<h2 id="padding">Padding<a class="headerlink" href="#padding" title="Permanent link">&para;</a></h2>
<p>The padding is added by the compiler so that the members are aligned. Typically, the members are aligned to their natural size. This means that a boolean variable, which is 1 byte, is aligned to 1 byte, while a 4-byte integer is aligned to 4 bytes.</p>
<p>Note that the compiler is not allowed to change the order of the members, and therefore, <strong>the order of the members affects the size of the structure in memory!</strong> Example:</p>
<pre><code class="language-cpp">struct A{ // 4 bytes
    bool b; // 1 byte
    bool b2; // 1 byte
    short a; // 2 bytes
};

struct B{ // 4 bytes
    short a; // 2 bytes
    bool b; // 1 byte
    bool b2; // 1 byte
};

struct C{ // 5 bytes
    bool b; // 1 byte + 1 byte padding so that the short is aligned 
    short a; // 2 bytes
    bool b2; // 1 byte
</code></pre>
<p>The natural alignment apply to the basic types. The composed types (e.g., structs, classes, unions) are typically aligned to the largest member.</p>
<h2 id="structure-alignment-or-final-padding">Structure Alignment (or final padding)<a class="headerlink" href="#structure-alignment-or-final-padding" title="Permanent link">&para;</a></h2>
<p>Appart from padding, each data structure is alligned to its largest member. If the data structure size (including padding) is not a multiple of its alignment, it effectively takes more memory so that it is aligned.</p>
<h1 id="specific-tasks">specific tasks<a class="headerlink" href="#specific-tasks" title="Permanent link">&para;</a></h1>
<h2 id="conditional-function-execution">Conditional Function Execution<a class="headerlink" href="#conditional-function-execution" title="Permanent link">&para;</a></h2>
<p>W know it from other languages: if the function can be run in two (or more) modes, there is a function parameter that controls the execution. Usually, most of the function is the same (otherwise, we eould create multiple fuctions), and the switch controls just a small part.</p>
<p>Unlike in other langueges. C++ has not one, but three options how to implement this.  They are described below in atable together with theai properties.</p>
<table>
<thead>
<tr>
<th></th>
<th>function parameter</th>
<th>template parameter</th>
<th>compiler directive</th>
</tr>
</thead>
<tbody>
<tr>
<td>good readability</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>compiler optimization</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>conditional code compilation</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody>
</table>
<h3 id="function-parameter">Function Parameter<a class="headerlink" href="#function-parameter" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">void(bool switch = true){
    if(switch){
        ...
    }
    else{
        ...
    }
}
</code></pre>
<h3 id="template-parameter">Template Parameter<a class="headerlink" href="#template-parameter" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">template&lt;bool S = true&gt;
void(){
    if(S){
        ...
    }
    else{
        ...
    }
}
</code></pre>
<h3 id="compiler-directive">Compiler Directive<a class="headerlink" href="#compiler-directive" title="Permanent link">&para;</a></h3>
<pre><code class="language-cpp">void(){
#ifdef SWITCH
    ...
#else
    ...
#endif
}
</code></pre>
<h2 id="ignoring-warnings-for-specific-line-of-code">Ignoring warnings for specific line of code<a class="headerlink" href="#ignoring-warnings-for-specific-line-of-code" title="Permanent link">&para;</a></h2>
<p>Sometimes, we want to suppress some warnings, mostly in libraries we are including. The syntax is, unfortunatelly, different for each compiler. Example:</p>
<pre><code class="language-cpp">#if defined(_MSC_VER)
    #pragma warning(push)
    #pragma warning(disable: &lt;WARNING CODE&gt;)
#elif defined(__GNUC__)
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored &quot;&lt;WARNING TYPE GCC&gt;&quot;
#elif defined(__clang__)
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored &quot;&lt;WARNING TYPE CLANG&gt;&quot;
#endif
.. affected code...
#if defined(_MSC_VER)
    #pragma warning(pop)
#elif defined(__GNUC__)
    #pragma GCC diagnostic pop
#elif defined(__clang__)
    #pragma clang diagnostic pop
#endif
</code></pre>
<p>Here, the <code>&lt;WARNING CODE&gt;</code> is the code of the warning to be suppressed without the <code>C</code> prefix.</p>
<p><strong>Note that warnings related to the preprocessor macros cannot be suppressed this way in GCC</strong> due to a <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53431">bug</a> (fixed in GCC 13). The same is true for conditions:</p>
<pre><code class="language-cpp">#if 0
    #pragma sdhdhs // unknown pragma raises warning, despite unreachcable
#endif
</code></pre>
<h2 id="measuring-used-resource">Measuring used resource<a class="headerlink" href="#measuring-used-resource" title="Permanent link">&para;</a></h2>
<h3 id="memory">Memory<a class="headerlink" href="#memory" title="Permanent link">&para;</a></h3>
<h4 id="msvc">MSVC<a class="headerlink" href="#msvc" title="Permanent link">&para;</a></h4>
<p>In MSVC, we can measure the peak used memory using the following code: </p>
<pre><code class="language-cpp">#include &lt;psapi.h&gt;

PROCESS_MEMORY_COUNTERS pmc;
K32GetProcessMemoryInfo(GetCurrentProcess(), &amp;pmc, sizeof(pmc));
auto max_mem = pmc.PeakWorkingSetSize
</code></pre>
<h2 id="working-with-tabular-data">Working with tabular data<a class="headerlink" href="#working-with-tabular-data" title="Permanent link">&para;</a></h2>
<p>Potential libs similar to Python Pandas:</p>
<ul>
<li><a href="https://arrow.apache.org/docs/cpp/">Arrow</a></li>
<li><a href="https://github.com/hosseinmoein/DataFrame">Dataframe</a></li>
</ul>
<h2 id="executing-external-commands">Executing external commands<a class="headerlink" href="#executing-external-commands" title="Permanent link">&para;</a></h2>
<p>The support for executing external commands in C++ is unsatisfactory. The most common solution is to use the <a href="https://en.cppreference.com/w/cpp/utility/program/system"><code>system</code></a> function.
However, the <code>system</code> calls are not portable, e.g., the quotes around the command are not supported in Windows</p>
<p>Another option is to use the Boost <a href="https://www.boost.org/doc/libs/1_82_0/doc/html/process.html">Process</a> library. </p>
<h2 id="command-line-interface">Command Line Interface<a class="headerlink" href="#command-line-interface" title="Permanent link">&para;</a></h2>
<p>For CLI, please follow the <a href="../../Common/#command-line-interface">CLI manual</a>. Here we focus on setting up the <a href="http://tclap.sourceforge.net/manual.html">TCLAP</a> library.</p>
<p>TCLAP use</p>
<h2 id="jinja-like-templating">Jinja-like Templating<a class="headerlink" href="#jinja-like-templating" title="Permanent link">&para;</a></h2>
<p>For working with Jinja-like templates, we can use the <a href="https://github.com/pantor/inja">Inja</a> template engine. </p>
<h3 id="exceptions_1">Exceptions<a class="headerlink" href="#exceptions_1" title="Permanent link">&para;</a></h3>
<p>There are the following exceptions types:</p>
<ul>
<li><code>ParserError</code> thrown on <code>parse_template</code> method</li>
<li><code>RenderError</code> thrown on <code>write</code> method</li>
</ul>
<h4 id="render-errors">Render Errors<a class="headerlink" href="#render-errors" title="Permanent link">&para;</a></h4>
<ul>
<li><code>empty expression</code>: this signalize that some expression is empty. Unfortunatelly, the line number is incorrect (it is always 1). Look for empty conditions, loops, etc. (e.g., <code>{% if %}</code>, <code>{% for %}</code>, <code>{% else if %}</code>).</li>
</ul></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
